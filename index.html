<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>global-metadata.dat Editor</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; }
    #container { display: flex; flex-direction: column; height: 100vh; }
    #controls { padding: 10px; background: #f4f4f4; display: flex; align-items: center; gap: 10px; }
    #progress { flex: 1; }
    #tableContainer { overflow-y: scroll; flex: 1; font-family: monospace; }
    table { border-collapse: collapse; width: 100%; }
    td, th { border: 1px solid #ccc; padding: 4px; white-space: pre; }
    input[type="text"] { width: 100%; }
  </style>
</head>
<body>
<div id="container">
  <div id="controls">
    <input type="file" id="fileInput" />
    <input type="text" id="searchInput" placeholder="Search (case-sensitive)" />
    <progress id="progress" max="100" value="0"></progress>
    <button id="saveBtn">Save</button>
  </div>
  <div id="tableContainer">
    <table id="stringTable">
      <thead><tr><th>Offset</th><th>Original</th><th>Modified</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
let originalBuffer, stringEntries = [], modifiedStrings = {};

const readString = (dataView, offset, length) => {
  const bytes = new Uint8Array(dataView.buffer, offset, length);
  return new TextDecoder('utf-8').decode(bytes);
};

document.getElementById('fileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const arrayBuffer = await file.arrayBuffer();
  originalBuffer = arrayBuffer;

  const dataView = new DataView(arrayBuffer);
  const length = arrayBuffer.byteLength;
  const printable = /[ -~]/; // ASCII printable (includes space)
  let strings = [], offset = 0, str = '';

  const addString = (str, startOffset) => {
    if (str.length >= 4) {
      strings.push({ offset: startOffset, original: str });
    }
  };

  const batchSize = 100;
  let currentOffset = 0;

  const processChunk = () => {
    const start = currentOffset;
    let added = 0;

    while (currentOffset < length) {
      const byte = dataView.getUint8(currentOffset);
      const char = String.fromCharCode(byte);

      if (printable.test(char)) {
        if (str === '') offset = currentOffset;
        str += char;
      } else {
        if (str.length >= 4) {
          addString(str, offset);
          added++;
          if (added >= batchSize) break;
        }
        str = '';
      }

      currentOffset++;
    }

    document.getElementById('progress').value = Math.floor((currentOffset / length) * 100);

    if (currentOffset >= length) {
      populateTable(strings);
    } else {
      setTimeout(processChunk, 0); // avoid blocking UI
    }
  };

  processChunk();
});

function populateTable(strings) {
  const tbody = document.querySelector('#stringTable tbody');
  tbody.innerHTML = '';
  stringEntries = strings;

  for (const { offset, original } of strings) {
    const row = document.createElement('tr');
    const offsetCell = document.createElement('td');
    offsetCell.textContent = `0x${offset.toString(16)}`;
    const originalCell = document.createElement('td');
    originalCell.textContent = original;
    const modifiedCell = document.createElement('td');
    const input = document.createElement('input');
    input.value = original;
    input.dataset.offset = offset;
    input.addEventListener('input', () => {
      modifiedStrings[offset] = input.value;
    });
    modifiedCell.appendChild(input);
    row.append(offsetCell, originalCell, modifiedCell);
    tbody.appendChild(row);
  }
}

document.getElementById('searchInput').addEventListener('input', (e) => {
  const term = e.target.value;
  const rows = document.querySelectorAll('#stringTable tbody tr');
  rows.forEach(row => {
    const original = row.cells[1].textContent;
    const modified = row.cells[2].firstChild.value;
    row.style.display = (original.includes(term) || modified.includes(term)) ? '' : 'none';
  });
});

document.getElementById('saveBtn').addEventListener('click', () => {
  const view = new Uint8Array(originalBuffer);
  const encoder = new TextEncoder();
  let appendedData = [];

  for (const entry of stringEntries) {
    const { offset, original } = entry;
    const modified = modifiedStrings[offset];

    if (modified && modified !== original) {
      const encoded = encoder.encode(modified);
      if (encoded.length <= original.length) {
        // In-place overwrite
        view.set(encoded, offset);
        for (let i = offset + encoded.length; i < offset + original.length; i++) {
          view[i] = 0x20; // pad with space
        }
      } else {
        // Append to end
        const newOffset = view.length + appendedData.length;
        appendedData.push(...encoded);
        // TODO: Update offset in header if needed
      }
    }
  }

  const finalArray = new Uint8Array(view.length + appendedData.length);
  finalArray.set(view);
  finalArray.set(new Uint8Array(appendedData), view.length);

  const blob = new Blob([finalArray], { type: 'application/octet-stream' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'global-metadata-modified.dat';
  a.click();
});
</script>
</body>
</html>
