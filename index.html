<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #version {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 0.75em;
    color: #888;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.1.0</div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th>Index</th><th>Original String</th><th>Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer;
  let dataView;
  let stringLiterals = [];
  let stringLiteralOffset = 0;
  let stringLiteralCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;

  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  // Render table rows incrementally for smooth UI
  function updateTable() {
    const filter = searchInput.value;
    tableBody.innerHTML = '';
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < stringLiterals.length; i++) {
      const s = stringLiterals[i];
      if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;
      const tr = document.createElement('tr');
      const tdIndex = document.createElement('td');
      tdIndex.textContent = s.index;
      tr.appendChild(tdIndex);
      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      tr.appendChild(tdOrig);
      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.spellcheck = false;
      input.addEventListener('input', e => {
        s.modified = e.target.value;
      });
      tdMod.appendChild(input);
      tr.appendChild(tdMod);
      fragment.appendChild(tr);
    }
    tableBody.appendChild(fragment);
  }

  async function parseStringLiterals() {
    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);

    // Validate magic number
    const magic = dataView.getUint32(0, true);
    if (magic !== 0xFAB11BAF) {
      alert('Invalid global-metadata.dat file.');
      return;
    }

    // Read string literal metadata offsets/counts
    stringLiteralOffset = dataView.getUint32(0x58, true);
    stringLiteralCount = dataView.getUint32(0x5C, true);
    stringLiteralDataOffset = dataView.getUint32(0x60, true);
    stringLiteralDataSize = dataView.getUint32(0x64, true);

    stringLiterals = [];

    const batchSize = 500;
    for (let i = 0; i < stringLiteralCount; i++) {
      const entryOffset = stringLiteralOffset + i * 8;
      if (entryOffset + 8 > arrayBuffer.byteLength) break;

      const relativeOffset = dataView.getUint32(entryOffset, true);
      const length = dataView.getUint32(entryOffset + 4, true);
      const absoluteOffset = stringLiteralDataOffset + relativeOffset;

      // Validate offsets and lengths to avoid OOB
      if (absoluteOffset + length > arrayBuffer.byteLength) continue;

      const bytes = u8.slice(absoluteOffset, absoluteOffset + length);
      let text;
      try {
        text = new TextDecoder().decode(bytes);
      } catch {
        text = '';
      }

      // Filter out unprintable or empty strings
      if (!text || text.trim().length === 0) continue;

      stringLiterals.push({ index: i, offset: absoluteOffset, length, original: text, modified: text });

      if (i % batchSize === 0) {
        updateProgress(i / stringLiteralCount);
        updateTable();
        await new Promise(r => setTimeout(r, 0));
      }
    }
    updateProgress(1);
    updateTable();
    saveBtn.disabled = false;
  }

  fileInput.addEventListener('change', async () => {
    if (!fileInput.files.length) return;
    saveBtn.disabled = true;
    tableBody.innerHTML = '';
    updateProgress(0);
    const file = fileInput.files[0];
    arrayBuffer = await file.arrayBuffer();
    await parseStringLiterals();
  });

  searchInput.addEventListener('input', () => {
    updateTable();
  });

  saveBtn.addEventListener('click', () => {
    if (!arrayBuffer || !stringLiterals.length) return;

    const u8 = new Uint8Array(arrayBuffer);
    const newBufferSize = arrayBuffer.byteLength + 1024 * 1024 * 10; // +10MB buffer for appended strings
    const newBuffer = new Uint8Array(newBufferSize);
    newBuffer.set(u8);
    const newDataView = new DataView(newBuffer.buffer);

    let dataEnd = stringLiteralDataOffset + stringLiteralDataSize;

    for (const s of stringLiterals) {
      if (s.modified === s.original) continue;

      const encoded = new TextEncoder().encode(s.modified);

      if (encoded.length <= s.length) {
        // Overwrite in place with padding zeros
        for (let i = 0; i < encoded.length; i++) {
          newBuffer[s.offset + i] = encoded[i];
        }
        for (let i = encoded.length; i < s.length; i++) {
          newBuffer[s.offset + i] = 0;
        }
      } else {
        // Append at the end of string data block
        for (let i = 0; i < encoded.length; i++) {
          newBuffer[dataEnd + i] = encoded[i];
        }

        // Update offset and length in string literal table
        const newRelativeOffset = dataEnd - stringLiteralDataOffset;
        const entryOffset = stringLiteralOffset + s.index * 8;
        newDataView.setUint32(entryOffset, newRelativeOffset, true);
        newDataView.setUint32(entryOffset + 4, encoded.length, true);

        // Update new string literal offset & length in our object for UI correctness
        s.offset = dataEnd;
        s.length = encoded.length;

        dataEnd += encoded.length;
      }
    }

    // Update string literal data size in header (offset 0x64)
    const newStringDataSize = dataEnd - stringLiteralDataOffset;
    newDataView.setUint32(0x64, newStringDataSize, true);

    // Create blob of trimmed size
    const finalBlob = new Blob([newBuffer.slice(0, dataEnd)], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(finalBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'global-metadata.modified.dat';
    a.click();
    URL.revokeObjectURL(url);
  });

})();
</script>
</body>
</html>
