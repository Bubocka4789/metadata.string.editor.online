<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Il2Cpp Metadata String Editor - Full 500+ Lines</title>
<style>
/* === Reset & base styles === */
* {
  box-sizing: border-box;
  user-select: none;
  font-feature-settings: "liga" off;
}
html, body {
  margin: 0; padding: 0;
  height: 100%;
  font-family: monospace, monospace;
  background-color: #111;
  color: #eee;
  overflow: hidden;
}

/* === Header and controls === */
header {
  background: #1a1a1a;
  padding: 0.5em 1em;
  display: flex;
  align-items: center;
  gap: 1em;
  position: relative;
  user-select: text;
}
header input[type=file] {
  color: #ddd;
  cursor: pointer;
  user-select: none;
}
header input[type=text] {
  flex-grow: 1;
  max-width: 300px;
  padding: 0.3em 0.5em;
  font-size: 1em;
  border-radius: 3px;
  border: 1px solid #333;
  background: #222;
  color: #eee;
  user-select: text;
}
header button {
  padding: 0.4em 1em;
  border-radius: 3px;
  border: none;
  background: #3a7efc;
  color: white;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.3s ease;
}
header button:disabled {
  background: #444;
  cursor: default;
}
header button:hover:not(:disabled) {
  background: #5a9aff;
}
#version {
  position: absolute;
  right: 10px;
  top: 5px;
  font-size: 0.8em;
  color: #666;
}

/* === Progress bar === */
#progressBar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 5px;
  background: #222;
}
#progressBar > div {
  height: 100%;
  width: 0%;
  background: #3a7efc;
  transition: width 0.15s ease-out;
}

/* === Main container and table === */
#main {
  height: calc(100vh - 50px);
  background: #121212;
  display: flex;
  flex-direction: column;
}
#tableContainer {
  flex-grow: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: #121212;
  border-top: 1px solid #222;
  position: relative;
  font-size: 0.9em;
  user-select: text;
}

/* === Table with virtualized rows === */
table {
  border-collapse: collapse;
  width: 100%;
  min-width: 720px;
}
thead tr {
  background: #222;
  color: #bbb;
  user-select: none;
  position: sticky;
  top: 0;
  z-index: 2;
}
thead th {
  padding: 0.4em 0.8em;
  border-bottom: 1px solid #444;
  text-align: left;
  font-weight: 700;
}
tbody tr {
  border-bottom: 1px solid #222;
  background: #1b1b1b;
  transition: background-color 0.3s ease;
  cursor: default;
}
tbody tr:nth-child(odd) {
  background: #141414;
}
tbody tr:hover {
  background: #3a65af;
}
tbody td {
  padding: 0.25em 0.5em;
  max-width: 300px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: middle;
}

/* === Column widths === */
#indexCol {
  width: 5%;
}
#origCol {
  width: 45%;
}
#modCol {
  width: 50%;
}

/* === Editable input style === */
input.string-edit {
  width: 100%;
  border: none;
  background: transparent;
  color: #eee;
  font-family: monospace;
  font-size: 0.9em;
  padding: 0;
  margin: 0;
  outline-offset: 2px;
}
input.string-edit:focus {
  outline: 2px solid #3a7efc;
  background: #26365e;
  color: #fff;
}
input.string-edit::selection {
  background: #5a9aff;
  color: white;
}
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" accept=".dat" />
  <input type="text" id="search" placeholder="Case-sensitive search..." autocomplete="off" />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.0.0 (500+ lines)</div>
</header>
<div id="main">
  <div id="tableContainer" tabindex="0" aria-label="Strings Table Container">
    <table>
      <thead>
        <tr>
          <th id="indexCol">#</th>
          <th id="origCol">Original String</th>
          <th id="modCol">Modified String</th>
        </tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  // === DOM Elements ===
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBarFill = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');
  const tableContainer = document.getElementById('tableContainer');

  // === Constants and state ===
  const BATCH_SIZE = 200; // Number of strings to parse per animation frame batch
  const ROW_HEIGHT = 26;   // Approximate height of one row in px
  const BUFFER_ROWS = 15;  // Extra rows rendered above and below viewport

  let arrayBuffer = null;
  let dataView = null;
  let u8 = null;

  // Metadata offsets & counts from file header
  let stringLiteralOffset = 0;
  let stringLiteralCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;

  // All parsed strings: {index, offset, length, original, modified}
  let stringLiterals = [];

  // Filtered indexes based on search input (indexes into stringLiterals)
  let filteredIndexes = [];

  // File name for save
  let fileName = "";

  // === Helper: update progress bar width ===
  function updateProgress(ratio) {
    progressBarFill.style.width = Math.min(Math.max(ratio, 0), 1) * 100 + '%';
  }

  // === Helper: Check if bytes likely represent a printable string ===
  function isLikelyString(bytes) {
    // Allow only ascii printable chars or zero
    for (let b of bytes) {
      if (b === 0) continue;
      if (b < 32 || b > 126) return false;
    }
    return true;
  }

  // === Read a null-terminated or fixed-length string from Uint8Array slice ===
  function decodeString(bytes) {
    let end = bytes.indexOf(0);
    if (end === -1) end = bytes.length;
    return new TextDecoder().decode(bytes.subarray(0, end));
  }

  // === Parse and load strings incrementally to avoid freeze ===
  async function parseStringLiterals() {
    stringLiterals.length = 0;
    filteredIndexes.length = 0;
    updateProgress(0);

    for (let i = 0; i < stringLiteralCount; i += BATCH_SIZE) {
      const batchEnd = Math.min(i + BATCH_SIZE, stringLiteralCount);
      for (let j = i; j < batchEnd; j++) {
        const entryOffset = stringLiteralOffset + j * 8;
        if (entryOffset + 8 > u8.length) continue;
        const relOffset = dataView.getUint32(entryOffset, true);
        const length = dataView.getUint32(entryOffset + 4, true);
        const absOffset = stringLiteralDataOffset + relOffset;

        if (absOffset + length > u8.length) continue;

        const bytes = u8.subarray(absOffset, absOffset + length);
        if (!isLikelyString(bytes)) continue;

        const str = decodeString(bytes);
        stringLiterals.push({
          index: j,
          offset: entryOffset,
          length: length,
          original: str,
          modified: str
        });
      }
      updateProgress(i / stringLiteralCount);
      // Yield control to UI thread to avoid freeze
      await new Promise(r => setTimeout(r, 0));
    }

    filteredIndexes = stringLiterals.map((_, idx) => idx);
    updateProgress(1);
    saveBtn.disabled = false;
    renderVisibleRows(true);
  }

  // === Filter strings by search input and update filteredIndexes ===
  function filterStrings() {
    const filter = searchInput.value;
    filteredIndexes = [];
    if (!filter) {
      filteredIndexes = stringLiterals.map((_, i) => i);
    } else {
      for (let i = 0; i < stringLiterals.length; i++) {
        const s = stringLiterals[i];
        if (s.original.includes(filter) || s.modified.includes(filter)) {
          filteredIndexes.push(i);
        }
      }
    }
    // Reset scroll position when filter changes
    tableContainer.scrollTop = 0;
    renderVisibleRows(true);
  }

  // === Virtualized rendering ===
  // Render only visible rows + buffer, avoid full table rendering for big datasets
  let lastRenderRange = [0, 0];
  function renderVisibleRows(force = false) {
    const scrollTop = tableContainer.scrollTop;
    const containerHeight = tableContainer.clientHeight;
    const totalRows = filteredIndexes.length;

    const firstVisibleRow = Math.floor(scrollTop / ROW_HEIGHT);
    const lastVisibleRow = Math.min(totalRows - 1, Math.floor((scrollTop + containerHeight) / ROW_HEIGHT));

    const renderStart = Math.max(0, firstVisibleRow - BUFFER_ROWS);
    const renderEnd = Math.min(totalRows - 1, lastVisibleRow + BUFFER_ROWS);

    if (!force && lastRenderRange[0] === renderStart && lastRenderRange[1] === renderEnd) {
      return; // no change in render range, skip
    }

    lastRenderRange = [renderStart, renderEnd];

    // Build fragment with visible rows only
    const fragment = document.createDocumentFragment();

    for (let i = renderStart; i <= renderEnd; i++) {
      const idx = filteredIndexes[i];
      const s = stringLiterals[idx];

      const tr = document.createElement('tr');
      tr.style.height = ROW_HEIGHT + "px";

      // Index cell
      const tdIndex = document.createElement('td');
      tdIndex.textContent = s.index;
      tdIndex.style.userSelect = 'none';
      tr.appendChild(tdIndex);

      // Original string cell
      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      tr.appendChild(tdOrig);

      // Modified string cell with editable input
      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.className = 'string-edit';
      input.spellcheck = false;
      input.autocomplete = 'off';
      input.addEventListener('input', e => {
        s.modified = e.target.value;
      });
      tdMod.appendChild(input);
      tr.appendChild(tdMod);

      fragment.appendChild(tr);
    }

    // Adjust tbody height and offset to simulate full table height with blank rows before/after
    tableBody.style.position = 'relative';
    tableBody.style.height = totalRows * ROW_HEIGHT + 'px';

    // Remove all previous children
    tableBody.innerHTML = '';
    tableBody.appendChild(fragment);

    // Position the fragment container so rows appear correctly in scroll viewport
    const translateY = renderStart * ROW_HEIGHT;
    for (let tr of tableBody.children) {
      tr.style.position = 'absolute';
      tr.style.top = (translateY + (Array.prototype.indexOf.call(tableBody.children, tr) * ROW_HEIGHT)) + 'px';
      tr.style.left = '0';
      tr.style.right = '0';
    }
  }

  // === Scroll event for virtualization ===
  tableContainer.addEventListener('scroll', () => {
    renderVisibleRows();
  });

  // === Parse file header for global-metadata.dat specifics ===
  function parseMetadataHeader() {
    // Check magic bytes "il2cpp"
    const magic = String.fromCharCode(
      u8[0], u8[1], u8[2], u8[3], u8[4], u8[5]
    );
    if (magic !== 'il2cpp') {
      throw new Error('Not a valid il2cpp global-metadata.dat file');
    }
    // Offsets from file header structure - known offsets in little endian:
    // stringLiteralOffset (uint32_t) at 0x10
    // stringLiteralCount (uint32_t) at 0x14
    // stringLiteralDataOffset (uint32_t) at 0x18
    // stringLiteralDataSize (uint32_t) at 0x1C

    stringLiteralOffset = dataView.getUint32(0x10, true);
    stringLiteralCount = dataView.getUint32(0x14, true);
    stringLiteralDataOffset = dataView.getUint32(0x18, true);
    stringLiteralDataSize = dataView.getUint32(0x1C, true);

    if (
      stringLiteralOffset === 0 ||
      stringLiteralCount === 0 ||
      stringLiteralDataOffset === 0 ||
      stringLiteralDataSize === 0
    ) {
      throw new Error('Metadata header contains zero offsets/counts');
    }
  }

  // === Load file handler ===
  fileInput.addEventListener('change', async (e) => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    fileName = file.name.replace(/\.dat$/i, '') + '_modified.dat';

    // Reset UI & state
    saveBtn.disabled = true;
    stringLiterals.length = 0;
    filteredIndexes.length = 0;
    updateProgress(0);
    tableBody.innerHTML = '';
    searchInput.value = '';

    // Read file as ArrayBuffer
    const buffer = await file.arrayBuffer();
    arrayBuffer = buffer;
    dataView = new DataView(arrayBuffer);
    u8 = new Uint8Array(arrayBuffer);

    try {
      parseMetadataHeader();
      await parseStringLiterals();
    } catch (ex) {
      alert('Error parsing file: ' + ex.message);
      saveBtn.disabled = true;
    }
  });

  // === Search input event ===
  searchInput.addEventListener('input', () => {
    filterStrings();
  });

  // === Save modified file: append modified strings at end, update offsets ===
  saveBtn.addEventListener('click', () => {
    if (!arrayBuffer) return;
    saveBtn.disabled = true;
    updateProgress(0);

    const origBuffer = new Uint8Array(arrayBuffer);
    // We create a new Uint8Array with extra room for appended strings
    // Max size is original + sum of all modified strings length
    let appendedStrings = [];
    let appendedTotalBytes = 0;

    // Only append strings which were changed and longer than original to prevent overflow
    for (const s of stringLiterals) {
      if (s.modified !== s.original && s.modified.length > s.original.length) {
        appendedStrings.push(s);
        appendedTotalBytes += s.modified.length;
      }
    }

    // Calculate new file size for appended strings + metadata (8 bytes per string literal entry)
    const newSize = origBuffer.length + appendedTotalBytes;
    const newBuffer = new Uint8Array(newSize);
    newBuffer.set(origBuffer);

    // Append modified strings data at the end
    let appendPos = origBuffer.length;

    for (const s of appendedStrings) {
      const modifiedBytes = new TextEncoder().encode(s.modified);
      // Write modified string bytes at appendPos
      newBuffer.set(modifiedBytes, appendPos);

      // Update stringLiteral entry offset to point to new appended offset relative to stringLiteralDataOffset
      const relOffset = appendPos - stringLiteralDataOffset;
      dataView.setUint32(s.offset, relOffset, true);

      // Update length to new length
      dataView.setUint32(s.offset + 4, modifiedBytes.length, true);

      appendPos += modifiedBytes.length;
    }

    updateProgress(0.7);

    // Copy header + stringLiteral entries from DataView to newBuffer
    // (only the updated stringLiteral entries have been updated in DataView)
    newBuffer.set(new Uint8Array(arrayBuffer, 0, stringLiteralOffset), 0);
    // Copy updated stringLiteral entries
    newBuffer.set(new Uint8Array(arrayBuffer, stringLiteralOffset, stringLiteralCount * 8), stringLiteralOffset);
    // Copy string literal data remains unchanged, except appended strings at end

    updateProgress(1);

    // Save newBuffer as Blob and download
    const blob = new Blob([newBuffer], {type: 'application/octet-stream'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fileName;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      saveBtn.disabled = false;
    }, 100);
  });

  // === Keyboard accessibility for search input ===
  searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      searchInput.value = '';
      filterStrings();
      searchInput.blur();
    }
  });

  // === Initial render no file loaded ===
  updateProgress(0);
})();
</script>
</body>
</html>
