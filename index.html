<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Metadata String & Full File Editor</title>
<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #121212;
    color: #eee;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  h1 {
    text-align: center;
    margin-bottom: 1rem;
  }
  #controls {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 1rem;
  }
  input[type="file"],
  input[type="text"],
  button {
    background: #000;
    color: #eee;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 0.4rem 0.6rem;
    font-size: 1rem;
    outline-offset: 2px;
    transition: border-color 0.2s ease;
  }
  input[type="file"]:focus,
  input[type="text"]:focus,
  button:focus {
    border-color: #4caf50;
  }
  #progress-container {
    display: none;
    width: 100%;
    max-width: 600px;
    margin: 0 auto 1rem auto;
    background: #333;
    border-radius: 8px;
    overflow: hidden;
    height: 20px;
  }
  #progress-bar {
    height: 100%;
    width: 0%;
    background: #4caf50;
    text-align: center;
    color: #fff;
    font-weight: bold;
    line-height: 20px;
    user-select: none;
    transition: width 0.2s ease;
    font-size: 0.9rem;
  }
  #full-file-container {
    margin-bottom: 1rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    max-height: 40vh;
  }
  #full-file-label {
    margin-bottom: 0.3rem;
    color: #90caf9;
    font-weight: bold;
  }
  #full-file-textarea {
    background: #1e1e1e;
    border: 1px solid #444;
    border-radius: 6px;
    color: #eee;
    font-family: monospace;
    font-size: 0.85rem;
    resize: vertical;
    flex-grow: 1;
    overflow: auto;
    padding: 0.5rem;
  }
  #string-list {
    max-height: 50vh;
    overflow-y: auto;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 0.5rem;
    background: #1e1e1e;
    user-select: text;
    font-family: monospace;
  }
  .string-item {
    background: #2a2a2a;
    padding: 0.5rem;
    border-radius: 4px;
    margin-bottom: 0.5rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
  }
  .string-label {
    flex-basis: 100%;
    color: #90caf9;
    font-size: 0.85rem;
    margin-bottom: 0.25rem;
    user-select: text;
  }
  .string-col {
    flex: 1 1 45%;
    display: flex;
    flex-direction: column;
    min-width: 200px;
  }
  .string-col label {
    font-size: 0.75rem;
    margin-bottom: 0.15rem;
    color: #bbb;
    user-select: none;
  }
  .string-col input {
    width: 100%;
    font-family: monospace;
    font-size: 1rem;
    background: #000;
    border: 1px solid #555;
    border-radius: 4px;
    color: #eee;
    padding: 0.3rem 0.5rem;
    transition: border-color 0.2s ease;
  }
  .string-col input:focus {
    border-color: #4caf50;
    outline: none;
  }
  .string-col input[readonly] {
    background: #222;
    color: #777;
    cursor: default;
  }
  @media (max-width: 600px) {
    .string-col {
      flex-basis: 100%;
    }
  }
</style>
</head>
<body>
  <h1>Metadata String & Full File Editor</h1>
  <div id="controls">
    <input type="file" id="file-input" accept=".dat" aria-label="Load .dat file" />
    <input type="text" id="search" placeholder="Search strings (case sensitive)..." aria-label="Search strings" />
    <button id="download-btn" aria-label="Download modified file">Download</button>
  </div>

  <div id="progress-container" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div id="progress-bar">0%</div>
  </div>

  <div id="full-file-container">
    <div id="full-file-label">Full File Content (Latin1 Encoding, Editable)</div>
    <textarea id="full-file-textarea" spellcheck="false" aria-label="Full file content editor"></textarea>
  </div>

  <div id="string-list" aria-live="polite" aria-relevant="additions"></div>

<script>
  const fileInput = document.getElementById('file-input');
  const progressBar = document.getElementById('progress-bar');
  const progressContainer = document.getElementById('progress-container');
  const stringList = document.getElementById('string-list');
  const searchInput = document.getElementById('search');
  const downloadBtn = document.getElementById('download-btn');
  const fullFileTextarea = document.getElementById('full-file-textarea');

  let entries = [];
  let buffer = null;

  // Decode buffer to latin1 string (1 byte = 1 char)
  function bufferToLatin1String(buf) {
    let s = '';
    const len = buf.length;
    const chunkSize = 0x8000;
    for(let i=0; i<len; i+=chunkSize){
      const chunk = buf.subarray(i, i+chunkSize);
      s += String.fromCharCode.apply(null, chunk);
    }
    return s;
  }

  // Encode latin1 string back to Uint8Array
  function latin1StringToBuffer(str) {
    const buf = new Uint8Array(str.length);
    for(let i=0; i<str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  }

  function updateProgress(percent) {
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
    progressContainer.setAttribute('aria-valuenow', percent);
  }

  function extractStrings(buf) {
    entries = [];
    const minLength = 3;
    const maxStrings = 100;
    let i = 0;
    const length = buf.length;

    while (i < length && entries.length < maxStrings) {
      if (buf[i] >= 0x20 && buf[i] <= 0x7E) {
        const start = i;
        while (i < length && buf[i] >= 0x20 && buf[i] <= 0x7E) i++;
        if (i === length || buf[i] === 0x00) {
          const strLen = i - start;
          if (strLen >= minLength) {
            const str = bufferToLatin1String(buf.subarray(start, i));
            entries.push({ offset: start, original: str, current: str });
          }
          if (i < length && buf[i] === 0x00) i++;
        }
      } else {
        i++;
      }
    }
  }

  function renderEntries(list) {
    stringList.innerHTML = '';
    if (list.length === 0) {
      stringList.textContent = 'No strings found.';
      return;
    }
    const fragment = document.createDocumentFragment();
    list.forEach(entry => {
      const div = document.createElement('div');
      div.className = 'string-item';

      const label = document.createElement('div');
      label.className = 'string-label';
      label.textContent = `[0x${entry.offset.toString(16).toUpperCase().padStart(8, '0')}]`;

      const originalCol = document.createElement('div');
      originalCol.className = 'string-col';
      const originalLabel = document.createElement('label');
      originalLabel.textContent = 'Original';
      const originalInput = document.createElement('input');
      originalInput.type = 'text';
      originalInput.value = entry.original;
      originalInput.readOnly = true;
      originalInput.setAttribute('aria-label', `Original string at offset 0x${entry.offset.toString(16)}`);
      originalCol.appendChild(originalLabel);
      originalCol.appendChild(originalInput);

      const modifiedCol = document.createElement('div');
      modifiedCol.className = 'string-col';
      const modifiedLabel = document.createElement('label');
      modifiedLabel.textContent = 'Modified';
      const modifiedInput = document.createElement('input');
      modifiedInput.type = 'text';
      modifiedInput.value = entry.current;
      modifiedInput.maxLength = entry.original.length;
      modifiedInput.setAttribute('aria-label', `Modified string at offset 0x${entry.offset.toString(16)}`);

      modifiedInput.addEventListener('input', () => {
        // Enforce printable ASCII only and max length
        let filtered = modifiedInput.value.replace(/[^\x20-\x7E]/g, '');
        if (filtered.length > entry.original.length) filtered = filtered.slice(0, entry.original.length);
        modifiedInput.value = filtered;
        entry.current = filtered;
      });

      modifiedCol.appendChild(modifiedLabel);
      modifiedCol.appendChild(modifiedInput);

      div.appendChild(label);
      div.appendChild(originalCol);
      div.appendChild(modifiedCol);

      fragment.appendChild(div);
    });
    stringList.appendChild(fragment);
  }

  searchInput.addEventListener('input', () => {
    const query = searchInput.value;
    if (!query) {
      renderEntries(entries);
      return;
    }
    // Case sensitive search in original or modified strings
    const filtered = entries.filter(e =>
      e.original.includes(query) || e.current.includes(query)
    );
    renderEntries(filtered);
  });

  fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (!file) return;

    entries = [];
    stringList.innerHTML = '';
    progressContainer.style.display = 'block';
    updateProgress(0);
    fullFileTextarea.value = '';

    const reader = new FileReader();
    reader.onload = () => {
      buffer = new Uint8Array(reader.result);

      // Show full file content (latin1)
      fullFileTextarea.value = bufferToLatin1String(buffer);

      // Extract strings and render
      extractStrings(buffer);
      renderEntries(entries);

      updateProgress(100);
      setTimeout(() => {
        progressContainer.style.display = 'none';
      }, 400);
    };
    reader.readAsArrayBuffer(file);
  });

  downloadBtn.addEventListener('click', () => {
    if (!buffer) return;

    // Update buffer from fullFileTextarea (latin1)
    const fullText = fullFileTextarea.value;
    if (fullText.length !== buffer.length) {
      if (!confirm('Warning: The full file text length has changed!\nThis may corrupt the file. Continue anyway?')) {
        return;
      }
    }
    // Use original length to avoid buffer issues
    const updatedBuffer = latin1StringToBuffer(fullText.padEnd(buffer.length, '\0').slice(0, buffer.length));

    // Overwrite updatedBuffer with modified strings (max length)
    entries.forEach(e => {
      const enc = new TextEncoder().encode(e.current.padEnd(e.original.length, '\0'));
      updatedBuffer.set(enc.subarray(0, e.original.length), e.offset);
    });

    const blob = new Blob([updatedBuffer], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'modified-metadata.dat';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
</script>
</body>
</html>
