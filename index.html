<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>MetaDataStringEditor - Live Incremental</title>
<style>
  body { font-family: Arial, sans-serif; padding: 10px; }
  #progress { margin: 10px 0; }
  #progressbar { width: 100%; }
  table { width: 100%; border-collapse: collapse; margin-top: 10px; }
  th, td { border: 1px solid #ccc; padding: 5px; }
  th { background: #eee; }
  input[type="text"] { width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<h1>MetaDataStringEditor - Live Incremental</h1>
<input type="file" id="fileInput" />
<div id="progress" hidden>
  <progress id="progressbar" value="0" max="100"></progress>
  <span id="progresstext">0%</span>
</div>
<br />
<input type="text" id="search" placeholder="Search (case sensitive)" disabled />
<button id="saveBtn" disabled>Save Modified File</button>
<table id="stringsTable" hidden>
  <thead><tr><th>Original</th><th>Modified</th></tr></thead>
  <tbody></tbody>
</table>

<script>
(() => {
  const fileInput = document.getElementById("fileInput");
  const progress = document.getElementById("progress");
  const progressbar = document.getElementById("progressbar");
  const progresstext = document.getElementById("progresstext");
  const searchInput = document.getElementById("search");
  const saveBtn = document.getElementById("saveBtn");
  const stringsTable = document.getElementById("stringsTable");
  const tbody = stringsTable.querySelector("tbody");

  let arrayBuffer;
  let dataView;
  let stringLiteralCount = 0;
  let stringLiteralOffset = 0;
  let decoder = new TextDecoder("utf-8");
  let encoder = new TextEncoder();

  // We'll keep minimal data only for displayed strings:
  // { index, offset, length, originalString, modifiedString }
  let loadedStrings = [];

  // Map index -> modifiedString for saving
  let modifiedStringsMap = {};

  // Parse header to get string literal table info
  function parseHeader() {
    stringLiteralCount = dataView.getUint32(0x50, true);
    stringLiteralOffset = dataView.getUint32(0x54, true);
    if (
      stringLiteralCount <= 0 ||
      stringLiteralOffset <= 0 ||
      stringLiteralOffset + stringLiteralCount * 8 > arrayBuffer.byteLength
    ) {
      alert("Invalid or corrupt string literal table data in header.");
      return false;
    }
    return true;
  }

  // Incrementally load strings in batches, update UI live
  function loadStringsIncrementally(batchSize = 50) {
    let currentIndex = 0;

    progress.hidden = false;
    stringsTable.hidden = false;
    searchInput.disabled = true;
    saveBtn.disabled = true;
    tbody.innerHTML = "";
    loadedStrings = [];
    modifiedStringsMap = {};

    function processBatch() {
      const fragment = document.createDocumentFragment();
      const maxIndex = Math.min(currentIndex + batchSize, stringLiteralCount);

      for (; currentIndex < maxIndex; currentIndex++) {
        const entryPos = stringLiteralOffset + currentIndex * 8;
        const strOffset = dataView.getUint32(entryPos, true);
        const strLength = dataView.getUint32(entryPos + 4, true);

        if (strOffset + strLength > arrayBuffer.byteLength) {
          console.warn(`String at index ${currentIndex} out of range, skipping`);
          continue;
        }

        const bytes = new Uint8Array(arrayBuffer, strOffset, strLength);
        const originalString = decoder.decode(bytes);

        const tr = document.createElement("tr");

        const tdOriginal = document.createElement("td");
        tdOriginal.textContent = originalString;
        tr.appendChild(tdOriginal);

        const tdModified = document.createElement("td");
        const input = document.createElement("input");
        input.type = "text";
        input.value = originalString;
        input.dataset.index = currentIndex;
        input.addEventListener("input", (e) => {
          const idx = e.target.dataset.index;
          loadedStrings[idx].modifiedString = e.target.value;
          modifiedStringsMap[idx] = e.target.value;
          filterTable();
        });
        tdModified.appendChild(input);
        tr.appendChild(tdModified);

        fragment.appendChild(tr);

        // Store minimal info
        loadedStrings[currentIndex] = {
          index: currentIndex,
          offset: strOffset,
          length: strLength,
          originalString: originalString,
          modifiedString: originalString,
        };
      }

      tbody.appendChild(fragment);

      // Update progress
      const percent = (currentIndex / stringLiteralCount) * 100;
      progressbar.value = percent;
      progresstext.textContent = percent.toFixed(1) + "%";

      if (currentIndex < stringLiteralCount) {
        // Yield to UI thread, process next batch later
        setTimeout(processBatch, 10);
      } else {
        // Done loading all strings
        progress.hidden = true;
        searchInput.disabled = false;
        saveBtn.disabled = false;
      }
    }

    processBatch();
  }

  // Filter table rows based on search input
  function filterTable() {
    const filter = searchInput.value;
    for (const tr of tbody.children) {
      const orig = tr.cells[0].textContent;
      tr.style.display = filter ? (orig.includes(filter) ? "" : "none") : "";
    }
  }

  searchInput.addEventListener("input", filterTable);

  // Save the modified file, preserving the original logic:
  // overwrite if modified string length <= original length
  // else append at EOF and update pointer+length in string literal table
  saveBtn.addEventListener("click", () => {
    // Calculate needed buffer size: original + extra for appended strings
    let newBufferSize = arrayBuffer.byteLength + 10 * 1024 * 1024; // +10MB buffer
    let newBuffer = new ArrayBuffer(newBufferSize);
    let newView = new DataView(newBuffer);
    let newUint8 = new Uint8Array(newBuffer);

    // Copy original data
    newUint8.set(new Uint8Array(arrayBuffer));

    // Append position
    let appendPos = arrayBuffer.byteLength;

    function setUint32LE(offset, val) {
      newView.setUint32(offset, val, true);
    }

    for (const item of loadedStrings) {
      const idx = item.index;
      const origLen = item.length;
      const origOffset = item.offset;
      const modified = item.modifiedString;

      const encoded = encoder.encode(modified);

      const entryOffset = stringLiteralOffset + idx * 8;

      if (encoded.length <= origLen) {
        // overwrite in place with padding zeros if shorter
        newUint8.set(encoded, origOffset);
        if (encoded.length < origLen) {
          newUint8.fill(0, origOffset + encoded.length, origOffset + origLen);
        }
        // no change to string literal table entry
      } else {
        // append at EOF
        newUint8.set(encoded, appendPos);
        setUint32LE(entryOffset, appendPos);
        setUint32LE(entryOffset + 4, encoded.length);
        appendPos += encoded.length;
      }
    }

    // Slice to actual size
    const finalBuffer = newBuffer.slice(0, appendPos);

    const blob = new Blob([finalBuffer], { type: "application/octet-stream" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "modified-global-metadata.dat";
    a.click();
  });

  fileInput.addEventListener("change", () => {
    const file = fileInput.files[0];
    if (!file) return;

    // Reset UI
    progress.hidden = false;
    progressbar.value = 0;
    progresstext.textContent = "0%";
    searchInput.value = "";
    searchInput.disabled = true;
    saveBtn.disabled = true;
    stringsTable.hidden = true;
    tbody.innerHTML = "";
    loadedStrings = [];
    modifiedStringsMap = {};

    const reader = new FileReader();
    reader.onload = (e) => {
      arrayBuffer = e.target.result;
      dataView = new DataView(arrayBuffer);
      if (!parseHeader()) {
        alert("Could not parse metadata header properly.");
        return;
      }
      loadStringsIncrementally();
    };
    reader.readAsArrayBuffer(file);
  });
})();
</script>
</body>
</html>
