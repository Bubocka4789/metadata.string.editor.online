<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MetaDataStringEditor Web Clone</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #versionLabel {
    position: absolute; top: 5px; right: 10px; font-size: 10px; color: #888;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="versionLabel">v2025.05.28</div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th>Offset (hex)</th><th>Original String</th><th>Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer, dataView;
  let stringLiterals = [];

  function readPrintableString(offset, length) {
    const bytes = new Uint8Array(arrayBuffer, offset, length);
    const decoded = new TextDecoder('utf-8', { fatal: false }).decode(bytes);
    return decoded.replace(/[^\x20-\x7E]+/g, ''); // filter to printable ASCII
  }

  function detectIl2CppStringLiteralTable() {
    // Known offsets and limits from reverse engineering Gorilla Tag metadata
    const searchStart = 0;
    const searchEnd = Math.min(arrayBuffer.byteLength - 8, 1_000_000);
    const table = [];

    for (let i = searchStart; i < searchEnd; i += 8) {
      const offset = new DataView(arrayBuffer).getUint32(i, true);
      const length = new DataView(arrayBuffer).getInt32(i + 4, true);

      if (
        offset > 0 &&
        length > 0 &&
        offset + length < arrayBuffer.byteLength &&
        length < 1000
      ) {
        const preview = readPrintableString(offset, length);
        if (preview && preview.match(/[A-Za-z0-9 _\-.,!?]/) && preview.length > 2) {
          table.push({ i, offset, length, original: preview, modified: preview });
        }
      }

      if (table.length > 0 && table.length % 500 === 0) {
        updateProgress(i / searchEnd);
      }
    }

    if (!table.length) return null;
    return table;
  }

  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  function updateTable() {
    const filter = searchInput.value;
    tableBody.innerHTML = '';
    const fragment = document.createDocumentFragment();

    for (const s of stringLiterals) {
      if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;

      const tr = document.createElement('tr');
      const tdOff = document.createElement('td');
      tdOff.textContent = '0x' + s.offset.toString(16).padStart(8, '0');
      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.spellcheck = false;
      input.addEventListener('input', e => s.modified = e.target.value);
      tdMod.appendChild(input);
      tr.appendChild(tdOff);
      tr.appendChild(tdOrig);
      tr.appendChild(tdMod);
      fragment.appendChild(tr);
    }

    tableBody.appendChild(fragment);
  }

  function saveModifiedFile() {
    const newBuffer = new Uint8Array(arrayBuffer);
    let appendOffset = arrayBuffer.byteLength;
    const appendedData = [];

    for (const s of stringLiterals) {
      if (s.modified === s.original) continue;

      const modBytes = new TextEncoder().encode(s.modified);
      const entryOffset = s.i;

      if (modBytes.length <= s.length) {
        newBuffer.set(modBytes, s.offset);
        for (let i = modBytes.length; i < s.length; i++) newBuffer[s.offset + i] = 0;
      } else {
        const newOffset = appendOffset;
        appendOffset += modBytes.length;
        appendedData.push({ offset: newOffset, bytes: modBytes });
        new DataView(newBuffer.buffer).setUint32(entryOffset, newOffset, true);
        new DataView(newBuffer.buffer).setInt32(entryOffset + 4, modBytes.length, true);
      }
    }

    if (appendedData.length > 0) {
      const finalBuffer = new Uint8Array(appendOffset);
      finalBuffer.set(newBuffer);
      for (const d of appendedData) finalBuffer.set(d.bytes, d.offset);
      const blob = new Blob([finalBuffer], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'global-metadata.modified.dat';
      a.click();
      URL.revokeObjectURL(url);
    } else {
      const blob = new Blob([newBuffer], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'global-metadata.modified.dat';
      a.click();
      URL.revokeObjectURL(url);
    }
  }

  fileInput.addEventListener('change', async () => {
    if (!fileInput.files.length) return;
    saveBtn.disabled = true;
    tableBody.innerHTML = '';
    updateProgress(0);

    const file = fileInput.files[0];
    arrayBuffer = await file.arrayBuffer();
    dataView = new DataView(arrayBuffer);

    const detectedTable = detectIl2CppStringLiteralTable();
    if (!detectedTable) {
      alert("Failed to detect Il2CppStringLiteral table offsets.");
      return;
    }

    stringLiterals = detectedTable;
    updateTable();
    saveBtn.disabled = false;
    updateProgress(1);
  });

  searchInput.addEventListener('input', () => {
    updateTable();
  });

  saveBtn.addEventListener('click', saveModifiedFile);
})();
</script>
</body>
</html>
