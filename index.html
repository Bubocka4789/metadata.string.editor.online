<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>MetaDataStringEditor Web Clone</title> <style> body { font-family: monospace; margin: 0; background: #111; color: #eee; } header { padding: 0.5em 1em; background: #222; position: relative; } input[type=file] { margin-right: 1em; } #progressBar { width: 100%; height: 20px; background: #333; margin: 0.5em 0; border-radius: 3px; overflow: hidden; } #progressBar div { height: 100%; background: #76aaff; width: 0%; } #search { width: 300px; padding: 0.3em; margin-bottom: 1em; background: #222; border: 1px solid #555; color: #eee; } #container { display: flex; height: 75vh; overflow: hidden; } table { border-collapse: collapse; width: 100%; table-layout: fixed; } th, td { border: 1px solid #333; padding: 0.2em 0.4em; overflow-wrap: break-word; word-break: break-all; vertical-align: top; background: #222; } th { background: #333; } td input { width: 100%; background: transparent; border: none; color: #eee; font-family: monospace; } td input:focus { outline: 1px solid #76aaff; } #stringsTable { flex: 1; overflow: auto; } #version { position: absolute; top: 5px; right: 10px; font-size: 0.75em; color: #888; } </style> </head> <body> <header> <input type="file" id="fileInput" /> <input type="text" id="search" placeholder="Case-sensitive search..." /> <button id="saveBtn" disabled>Save Modified File</button> <div id="progressBar"><div></div></div> <div id="version">v1.3</div> </header> <div id="container"> <div id="stringsTable"> <table> <thead> <tr><th>Offset (hex)</th><th>Original String</th><th>Modified String</th></tr> </thead> <tbody id="tableBody"></tbody> </table> </div> </div> <script> (() => { const fileInput = document.getElementById('fileInput'); const searchInput = document.getElementById('search'); const saveBtn = document.getElementById('saveBtn'); const progressBar = document.getElementById('progressBar').firstElementChild; const tableBody = document.getElementById('tableBody'); let arrayBuffer; let dataView; let stringLiterals = []; // { offset, length, original, modified } let modifiedCount = 0; function updateProgress(ratio) { progressBar.style.width = Math.floor(ratio * 100) + '%'; } function updateTable() { const filter = searchInput.value; tableBody.innerHTML = ''; const fragment = document.createDocumentFragment(); for (let i = 0; i < stringLiterals.length; i++) { const s = stringLiterals[i]; if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue; const tr = document.createElement('tr'); const tdOff = document.createElement('td'); tdOff.textContent = '0x' + s.offset.toString(16).padStart(8, '0'); tr.appendChild(tdOff); const tdOrig = document.createElement('td'); tdOrig.textContent = s.original; tr.appendChild(tdOrig); const tdMod = document.createElement('td'); const input = document.createElement('input'); input.type = 'text'; input.value = s.modified; input.spellcheck = false; input.addEventListener('input', e => { s.modified = e.target.value; modifiedCount = stringLiterals.filter(x => x.modified !== x.original).length; }); tdMod.appendChild(input); tr.appendChild(tdMod); fragment.appendChild(tr); } tableBody.appendChild(fragment); } function saveModifiedFile() { let newBuffer = new Uint8Array(arrayBuffer); for (const s of stringLiterals) { if (s.modified === s.original) continue; const encoded = new TextEncoder().encode(s.modified); if (encoded.length <= s.length) { for (let i = 0; i < encoded.length; i++) newBuffer[s.offset + i] = encoded[i]; for (let i = encoded.length; i < s.length; i++) newBuffer[s.offset + i] = 0; } } const blob = new Blob([newBuffer], { type: 'application/octet-stream' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'global-metadata.modified.dat'; a.click(); URL.revokeObjectURL(url); } // Brute-force readable strings (printable ASCII) async function extractAllPrintableStrings(minLen = 4) { const u8 = new Uint8Array(arrayBuffer); let i = 0; const batchSize = 50000; while (i < u8.length) { let end = Math.min(i + batchSize, u8.length); let chunk = u8.subarray(i, end); let strStart = null; for (let j = 0; j < chunk.length; j++) { let byte = chunk[j]; if (byte >= 32 && byte <= 126 || byte === 9) { if (strStart === null) strStart = i + j; } else { if (strStart !== null && (i + j - strStart) >= minLen) { const offset = strStart; const length = i + j - strStart; const text = new TextDecoder().decode(u8.slice(offset, offset + length)); stringLiterals.push({ offset, length, original: text, modified: text }); } strStart = null; } } i = end; updateProgress(i / u8.length); await new Promise(r => setTimeout(r, 0)); } updateProgress(1); saveBtn.disabled = false; updateTable(); } fileInput.addEventListener('change', async e => { if (!fileInput.files.length) return; saveBtn.disabled = true; tableBody.innerHTML = ''; updateProgress(0); stringLiterals = []; modifiedCount = 0; const file = fileInput.files[0]; arrayBuffer = await file.arrayBuffer(); dataView = new DataView(arrayBuffer); await extractAllPrintableStrings(4); // fallback mode: get readable strings }); searchInput.addEventListener('input', () => { updateTable(); }); saveBtn.addEventListener('click', saveModifiedFile); })(); </script> </body> </html>
