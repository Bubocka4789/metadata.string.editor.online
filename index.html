<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Metadata String Editor</title>
<style>
  /* same styling as before */
  /* ... omitted for brevity, keep previous styles here ... */
  /* just reuse previous style block */
</style>
</head>
<body>
<header>
  <div>Metadata String Editor</div>
  <button id="darkToggle">Dark Mode</button>
</header>
<main>
  <input type="file" id="fileInput" accept=".dat" />
  <div id="progressContainer"><div id="progressBar"></div></div>
  <input type="text" id="searchInput" placeholder="Search strings (case sensitive)..." disabled />
  <div id="stringList" tabindex="0"></div>
  <button id="saveBtn" disabled>Save Patched File</button>
</main>
<footer>
  &copy; 2025 Metadata String Editor
</footer>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const progressContainer = document.getElementById('progressContainer');
  const progressBar = document.getElementById('progressBar');
  const searchInput = document.getElementById('searchInput');
  const stringList = document.getElementById('stringList');
  const saveBtn = document.getElementById('saveBtn');
  const darkToggle = document.getElementById('darkToggle');
  const body = document.body;

  let binaryData = null;
  let entries = [];
  let filteredEntries = [];

  // Toggle Dark Mode
  darkToggle.addEventListener('click', () => {
    body.classList.toggle('dark');
    darkToggle.textContent = body.classList.contains('dark') ? 'Light Mode' : 'Dark Mode';
  });

  fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (!file) return;

    resetUI();

    const reader = new FileReader();

    reader.onprogress = (e) => {
      if (e.lengthComputable) {
        const percent = (e.loaded / e.total) * 100;
        progressBar.style.width = percent + '%';
        progressContainer.style.display = 'block';
      }
    };

    reader.onload = () => {
      progressBar.style.width = '100%';

      binaryData = new Uint8Array(reader.result);

      // Async chunked string extraction to avoid freeze
      entries = [];
      const chunkSize = 50000; // bytes to process per chunk
      let offset = 0;

      function processChunk() {
        const start = offset;
        const end = Math.min(offset + chunkSize, binaryData.length);

        extractStringsFromRange(start, end);

        offset = end;
        progressBar.style.width = (offset / binaryData.length) * 100 + '%';

        if (offset < binaryData.length) {
          setTimeout(processChunk, 10); // yield to UI thread
        } else {
          progressBar.style.width = '100%';
          progressContainer.style.display = 'none';

          if (entries.length === 0) {
            alert('No strings found in the file.');
            searchInput.disabled = true;
            saveBtn.disabled = true;
          } else {
            searchInput.disabled = false;
            saveBtn.disabled = false;
          }

          filteredEntries = [...entries];
          renderStringList();
        }
      }

      // Extract strings in [start,end) range
      function extractStringsFromRange(start, end) {
        let i = start;
        while (i < end) {
          if (binaryData[i] >= 0x20 && binaryData[i] <= 0x7E) {
            let strStart = i;
            while (i < end && binaryData[i] >= 0x20 && binaryData[i] <= 0x7E) i++;
            if (i < binaryData.length && binaryData[i] === 0x00) {
              let strLen = i - strStart;
              if (strLen >= 3) {
                const strBytes = binaryData.subarray(strStart, i);
                const str = new TextDecoder('ascii').decode(strBytes);
                entries.push({
                  offset: strStart,
                  original: str,
                  current: str,
                  length: strLen
                });
              }
            }
          }
          i++;
        }
      }

      processChunk();
    };

    reader.onerror = () => {
      alert('Failed to read file.');
      progressContainer.style.display = 'none';
    };

    reader.readAsArrayBuffer(file);
  });

  function resetUI() {
    progressBar.style.width = '0%';
    progressContainer.style.display = 'none';
    stringList.innerHTML = '';
    searchInput.value = '';
    searchInput.disabled = true;
    saveBtn.disabled = true;
    entries = [];
    filteredEntries = [];
    binaryData = null;
  }

  // Render list with inline editing
  function renderStringList() {
    stringList.innerHTML = '';
    filteredEntries.forEach((entry, idx) => {
      const div = document.createElement('div');
      div.className = 'stringEntry';

      const indexSpan = document.createElement('span');
      indexSpan.className = 'stringIndex';
      indexSpan.textContent = idx;

      const textSpan = document.createElement('span');
      textSpan.className = 'stringText';

      const input = document.createElement('input');
      input.type = 'text';
      input.value = entry.current;
      input.maxLength = entry.length;
      input.title = `Max length: ${entry.length}`;
      input.style.color = entry.current === entry.original ? '' : 'orange';

      input.addEventListener('input', () => {
        if (input.value.length <= entry.length) {
          entry.current = input.value;
          input.style.color = entry.current === entry.original ? '' : 'orange';
        } else {
          input.value = entry.current; // revert if too long
        }
      });

      textSpan.appendChild(input);
      div.appendChild(indexSpan);
      div.appendChild(textSpan);

      stringList.appendChild(div);
    });
  }

  // Search handler (case sensitive)
  searchInput.addEventListener('input', () => {
    const query = searchInput.value;
    if (query === '') {
      filteredEntries = [...entries];
    } else {
      filteredEntries = entries.filter(e => e.current.includes(query));
    }
    renderStringList();
  });

  // Save patched file
  saveBtn.addEventListener('click', () => {
    if (!binaryData) return;

    // Copy binary data so we can patch it
    const patched = new Uint8Array(binaryData);

    for (const e of entries) {
      if (e.current !== e.original) {
        const encoded = new TextEncoder().encode(e.current);
        for (let i = 0; i < e.length; i++) {
          patched[e.offset + i] = i < encoded.length ? encoded[i] : 0x00;
        }
      }
    }

    const blob = new Blob([patched], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'patched_global-metadata.dat';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
})();
</script>
</body>
</html>
