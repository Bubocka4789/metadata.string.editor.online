<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MetaDataStringEditor Web Clone</title>
<style>
  body { font-family: monospace; margin: 0; padding: 0; background: #222; color: #eee; }
  #container { padding: 1em; max-width: 1000px; margin: auto; }
  #fileInput { margin-bottom: 1em; }
  #searchBox { width: 100%; padding: 0.5em; margin-bottom: 1em; font-size: 1em; }
  #stringsTable { width: 100%; border-collapse: collapse; }
  #stringsTable th, #stringsTable td { border: 1px solid #444; padding: 0.3em 0.5em; }
  #stringsTable th { background: #333; }
  #stringsTable td.original { background: #111; color: #999; white-space: pre-wrap; word-break: break-word; }
  #stringsTable td.editable { background: #222; }
  #stringsTable td.editable textarea {
    width: 100%; height: 3em; resize: vertical; background: #222; color: #eee; border: none; outline: none;
    font-family: monospace; font-size: 0.9em;
  }
  #progressBar {
    width: 100%; background: #444; height: 12px; border-radius: 6px; overflow: hidden; margin-bottom: 1em;
  }
  #progressFill {
    height: 100%; background: #0af; width: 0%;
    transition: width 0.2s ease;
  }
  #saveBtn {
    background: #0a0; border: none; padding: 0.5em 1em; font-size: 1em; color: #eee;
    cursor: pointer; border-radius: 4px; margin-top: 1em;
  }
  #saveBtn:disabled {
    background: #333;
    cursor: not-allowed;
  }
</style>
</head>
<body>
  <div id="container">
    <h1>MetaDataStringEditor Web Clone</h1>
    <input type="file" id="fileInput" accept=".dat" />
    <input type="text" id="searchBox" placeholder="Search strings..." disabled />
    <div id="progressBar" hidden><div id="progressFill"></div></div>
    <table id="stringsTable" hidden>
      <thead><tr><th>#</th><th>Original String</th><th>Edited String</th></tr></thead>
      <tbody></tbody>
    </table>
    <button id="saveBtn" disabled>Save Edited Metadata</button>
  </div>

<script>
class MetadataParser {
  constructor(buffer) {
    this.buffer = buffer;
    this.dv = new DataView(buffer);
    this.strings = [];
    this.stringOffsets = [];
  }

  readInt32LE(offset) {
    return this.dv.getUint32(offset, true);
  }

  parse() {
    try {
      this.version = this.readInt32LE(0);
      console.log(`Metadata version: ${this.version}`);

      this.stringLiteralCount = this.readInt32LE(4);
      this.stringLiteralOffset = this.readInt32LE(8);

      // fallback if missing or invalid
      this.stringCount = this.readInt32LE(0x10);
      this.stringOffsetsOffset = this.readInt32LE(0x14);

      // Validate counts and offsets
      if (
        this.stringLiteralCount <= 0 ||
        this.stringLiteralOffset <= 0 ||
        this.stringLiteralOffset >= this.buffer.byteLength
      ) {
        throw new Error("Invalid string literal count or offset");
      }

      if (
        this.stringCount <= 0 ||
        this.stringOffsetsOffset <= 0 ||
        this.stringOffsetsOffset >= this.buffer.byteLength
      ) {
        console.warn(
          "Warning: string offsets table missing or invalid, trying fallback"
        );
        this.stringCount = this.stringLiteralCount;
        this.stringOffsetsOffset = this.stringLiteralOffset;
      }

      // Read string offsets
      this.stringOffsets = [];
      for (let i = 0; i < this.stringCount; i++) {
        let off = this.readInt32LE(this.stringOffsetsOffset + i * 4);
        if (off === 0) continue;
        if (off >= this.buffer.byteLength) {
          console.warn(`Invalid string offset ${off} at index ${i}, skipping`);
          continue;
        }
        this.stringOffsets.push(off);
      }

      // Parse strings (defer full extraction for incremental rendering)
      this.strings = this.stringOffsets.map(() => null);

      return true;
    } catch (e) {
      alert("Failed to parse metadata file: " + e.message);
      console.error(e);
      return false;
    }
  }

  readStringAtOffset(offset) {
    // String length is 4 bytes before offset
    if (offset < 4) return null;
    let len = this.readInt32LE(offset - 4);
    if (len <= 0 || len > 10_000_000) return null;
    if (offset + len > this.buffer.byteLength) return null;

    let bytes = new Uint8Array(this.buffer, offset, len);
    return new TextDecoder("utf-8").decode(bytes);
  }
}

document.addEventListener("DOMContentLoaded", () => {
  const fileInput = document.getElementById("fileInput");
  const searchBox = document.getElementById("searchBox");
  const progressBar = document.getElementById("progressBar");
  const progressFill = document.getElementById("progressFill");
  const stringsTable = document.getElementById("stringsTable");
  const tbody = stringsTable.querySelector("tbody");
  const saveBtn = document.getElementById("saveBtn");

  let metadataBuffer = null;
  let parser = null;
  let displayedStrings = []; // current filtered strings indices
  let batchSize = 100;
  let editingData = [];

  fileInput.addEventListener("change", async (e) => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];

    resetUI();

    metadataBuffer = await file.arrayBuffer();
    parser = new MetadataParser(metadataBuffer);

    if (!parser.parse()) return;

    editingData = new Array(parser.stringOffsets.length).fill(null);

    searchBox.disabled = false;
    stringsTable.hidden = false;
    saveBtn.disabled = false;
    progressBar.hidden = false;
    progressFill.style.width = "0%";

    // Incrementally load strings in batches
    displayedStrings = [...Array(parser.stringOffsets.length).keys()];
    renderStringsIncrementally(displayedStrings);
  });

  searchBox.addEventListener("input", () => {
    const query = searchBox.value.toLowerCase();
    // Filter strings indices by original string content
    displayedStrings = [];
    for (let i = 0; i < parser.stringOffsets.length; i++) {
      // Load string if not loaded yet (lazy)
      if (parser.strings[i] === null) {
        parser.strings[i] = parser.readStringAtOffset(parser.stringOffsets[i]);
      }
      if (!parser.strings[i]) continue;
      if (parser.strings[i].toLowerCase().includes(query)) {
        displayedStrings.push(i);
      }
    }
    tbody.innerHTML = "";
    renderStringsIncrementally(displayedStrings);
  });

  function renderStringsIncrementally(indices, start = 0) {
    if (start === 0) tbody.innerHTML = "";
    const end = Math.min(start + batchSize, indices.length);

    for (let i = start; i < end; i++) {
      const idx = indices[i];

      if (parser.strings[idx] === null) {
        parser.strings[idx] = parser.readStringAtOffset(parser.stringOffsets[idx]) || "";
      }

      const row = document.createElement("tr");

      const cellIndex = document.createElement("td");
      cellIndex.textContent = idx;
      row.appendChild(cellIndex);

      const cellOriginal = document.createElement("td");
      cellOriginal.classList.add("original");
      cellOriginal.textContent = parser.strings[idx];
      row.appendChild(cellOriginal);

      const cellEditable = document.createElement("td");
      cellEditable.classList.add("editable");
      const textarea = document.createElement("textarea");
      textarea.value = editingData[idx] ?? parser.strings[idx];
      textarea.dataset.index = idx;
      textarea.addEventListener("input", (e) => {
        editingData[idx] = e.target.value;
      });
      cellEditable.appendChild(textarea);
      row.appendChild(cellEditable);

      tbody.appendChild(row);
    }

    progressFill.style.width = `${((end / indices.length) * 100).toFixed(1)}%`;

    if (end < indices.length) {
      setTimeout(() => renderStringsIncrementally(indices, end), 10);
    } else {
      progressBar.hidden = true;
    }
  }

  saveBtn.addEventListener("click", () => {
    if (!metadataBuffer || !parser) return;

    try {
      // We'll create a new buffer that appends all modified strings at the end
      const originalBuffer = metadataBuffer;
      const origDV = new DataView(originalBuffer);
      const encoder = new TextEncoder();

      let newBufferLength = originalBuffer.byteLength;
      const newStringOffsets = [];

      // Calculate appended string data size & store new strings bytes
      const appendedStringsBytes = [];

      for (let i = 0; i < parser.stringOffsets.length; i++) {
        const originalStr = parser.strings[i] || "";
        const editedStr = editingData[i] !== null ? editingData[i] : originalStr;
        if (editedStr !== originalStr) {
          // Encode new string + length prefix (4 bytes)
          const encoded = encoder.encode(editedStr);
          const len = encoded.length;
          const lengthPrefix = new Uint8Array(4);
          new DataView(lengthPrefix.buffer).setUint32(0, len, true);
          appendedStringsBytes.push({ lengthPrefix, encoded, index: i });
          newBufferLength += 4 + len;
        } else {
          // Not changed, keep original offset
          newStringOffsets[i] = parser.stringOffsets[i];
        }
      }

      // Create new buffer and copy old data
      const newBuffer = new ArrayBuffer(newBufferLength);
      const newDV = new DataView(newBuffer);
      const newUint8 = new Uint8Array(newBuffer);
      newUint8.set(new Uint8Array(originalBuffer), 0);

      // Append new strings at the end
      let writeOffset = originalBuffer.byteLength;
      appendedStringsBytes.forEach(({ lengthPrefix, encoded, index }) => {
        newUint8.set(lengthPrefix, writeOffset);
        writeOffset += 4;
        newUint8.set(encoded, writeOffset);
        newStringOffsets[index] = writeOffset;
        writeOffset += encoded.length;
      });

      // Now update the string offsets table in the new buffer to point to new strings
      for (let i = 0; i < newStringOffsets.length; i++) {
        const off = newStringOffsets[i] || 0;
        newDV.setUint32(parser.stringOffsetsOffset + i * 4, off, true);
      }

      // Offer the new buffer as downloadable file
      const blob = new Blob([newBuffer], { type: "application/octet-stream" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "global-metadata-edited.dat";
      a.click();
      URL.revokeObjectURL(url);

    } catch (e) {
      alert("Failed to save edited metadata: " + e.message);
      console.error(e);
    }
  });

  function resetUI() {
    searchBox.value = "";
    searchBox.disabled = true;
    stringsTable.hidden = true;
    tbody.innerHTML = "";
    saveBtn.disabled = true;
    progressBar.hidden = true;
    progressFill.style.width = "0%";
    editingData = [];
  }
});
</script>
</body>
</html>
