<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>global-metadata.dat String Editor</title>
  <style>
    body { background: #121212; color: #eee; font-family: sans-serif; margin: 0; padding: 1rem; }
    h1 { text-align: center; }
    #controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem; }
    #controls input, #controls button {
      background: #222; color: white; border: 1px solid #555;
      padding: 0.5rem; border-radius: 4px;
    }
    #progress-bar { width: 100%; height: 20px; background: #333; margin-bottom: 1rem; border-radius: 4px; overflow: hidden; }
    #progress { height: 100%; background: #4caf50; width: 0%; text-align: center; line-height: 20px; color: white; }
    #string-list { max-height: 70vh; overflow-y: auto; border: 1px solid #333; padding: 1rem; background: #1e1e1e; }
    .entry { border-bottom: 1px solid #444; padding: 0.5rem 0; }
    .entry input { width: 100%; background: #111; color: #eee; border: 1px solid #555; margin-top: 0.25rem; padding: 0.3rem; }
    .label { color: #aaa; font-size: 0.85rem; }
  </style>
</head>
<body>
  <h1>global-metadata.dat Editor</h1>
  <div id="controls">
    <input type="file" id="fileInput" accept=".dat" />
    <input type="text" id="searchInput" placeholder="Search (case-sensitive)">
    <button id="downloadBtn">Download Modified</button>
  </div>
  <div id="progress-bar"><div id="progress">0%</div></div>
  <div id="string-list"></div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const progress = document.getElementById('progress');
    const list = document.getElementById('string-list');
    const searchInput = document.getElementById('searchInput');
    const downloadBtn = document.getElementById('downloadBtn');

    let buffer = null;
    let entries = [];

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files[0];
      if (!file) return;
      const arrayBuffer = await file.arrayBuffer();
      buffer = new Uint8Array(arrayBuffer);
      entries = [];

      list.innerHTML = '';
      updateProgress(0);
      extractStrings(buffer);
    });

    function updateProgress(p) {
      progress.style.width = p + '%';
      progress.textContent = p + '%';
    }

    function extractStrings(buf) {
      const decoder = new TextDecoder("ascii");
      const minLen = 3;
      const chunkSize = 100000;
      let i = 0;

      function processChunk() {
        const startTime = performance.now();
        while (i < buf.length) {
          if (buf[i] >= 0x20 && buf[i] <= 0x7E) {
            const start = i;
            while (i < buf.length && buf[i] >= 0x20 && buf[i] <= 0x7E) i++;
            if (i === buf.length || buf[i] === 0x00) {
              const str = decoder.decode(buf.slice(start, i));
              if (str.length >= minLen) {
                const entry = { offset: start, original: str, current: str };
                entries.push(entry);
                renderEntry(entry);
              }
              if (buf[i] === 0x00) i++;
            }
          } else {
            i++;
          }

          if (i % chunkSize === 0 || performance.now() - startTime > 50) {
            updateProgress(Math.floor((i / buf.length) * 100));
            return setTimeout(processChunk, 0);
          }
        }

        updateProgress(100);
      }

      processChunk();
    }

    function renderEntry(entry) {
      const div = document.createElement('div');
      div.className = 'entry';
      div.dataset.offset = entry.offset;

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = `Offset 0x${entry.offset.toString(16).padStart(8, '0')}`;

      const orig = document.createElement('input');
      orig.value = entry.original;
      orig.readOnly = true;

      const mod = document.createElement('input');
      mod.value = entry.current;
      mod.maxLength = entry.original.length;
      mod.addEventListener('input', () => {
        entry.current = mod.value.slice(0, entry.original.length);
      });

      div.append(label, orig, mod);
      list.appendChild(div);
    }

    searchInput.addEventListener('input', () => {
      const query = searchInput.value;
      const items = document.querySelectorAll('.entry');
      items.forEach(el => {
        const entry = entries.find(e => e.offset == el.dataset.offset);
        if (entry.original.includes(query) || entry.current.includes(query)) {
          el.style.display = '';
        } else {
          el.style.display = 'none';
        }
      });
    });

    downloadBtn.addEventListener('click', () => {
      if (!buffer || entries.length === 0) return;

      const updated = new Uint8Array(buffer);
      for (const e of entries) {
        const strBuf = new TextEncoder().encode(e.current.padEnd(e.original.length, '\0'));
        updated.set(strBuf.slice(0, e.original.length), e.offset);
      }

      const blob = new Blob([updated], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'modified-metadata.dat';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
