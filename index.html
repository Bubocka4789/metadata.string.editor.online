<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>global-metadata.dat Editor</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    input[type="file"] { margin-bottom: 1rem; }
    .progress { margin: 1rem 0; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 0.5rem; }
    th { background: #eee; }
    input[type="text"] { width: 100%; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <h1>global-metadata.dat String Editor</h1>
  <input type="file" id="fileInput"><br>
  <div class="progress">
    <progress id="progressBar" max="100" value="0"></progress>
    <span id="progressText">0%</span>
  </div>
  <input type="text" id="search" placeholder="Search (case sensitive)">
  <button id="saveBtn">Download Modified File</button>
  <table id="stringTable">
    <thead>
      <tr><th>Original</th><th>Modified</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const fileInput = document.getElementById("fileInput");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const stringTable = document.getElementById("stringTable").querySelector("tbody");
    const searchInput = document.getElementById("search");
    const saveBtn = document.getElementById("saveBtn");

    let originalBuffer, view, stringLiterals = [], modifiedStrings = {};
    const TEXT_DECODER = new TextDecoder("utf-8");
    const TEXT_ENCODER = new TextEncoder();

    fileInput.addEventListener("change", () => {
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        originalBuffer = reader.result;
        view = new DataView(originalBuffer);
        parseHeaderAndStrings();
      };
      reader.readAsArrayBuffer(file);
    });

    function parseHeaderAndStrings() {
      let offset = 0;
      let stringLiteralCount = view.getUint32(0x50, true);
      let stringLiteralOffset = view.getUint32(0x54, true);
      stringLiterals = [];

      const batchSize = 100;
      let i = 0;

      function processChunk() {
        const start = i;
        const end = Math.min(i + batchSize, stringLiteralCount);
        for (; i < end; i++) {
          let entryOffset = stringLiteralOffset + i * 8;
          let strOffset = view.getUint32(entryOffset, true);
          let strLength = view.getUint32(entryOffset + 4, true);

          if (strOffset + strLength > originalBuffer.byteLength) continue;

          const slice = new Uint8Array(originalBuffer, strOffset, strLength);
          const str = TEXT_DECODER.decode(slice);
          if (!str || /[\u0000-\u001F]/.test(str)) continue; // Skip invalid

          stringLiterals.push({ index: i, offset: strOffset, length: strLength, value: str });
          addStringRow(i, str);
        }

        updateProgress((i / stringLiteralCount) * 100);

        if (i < stringLiteralCount) {
          requestAnimationFrame(processChunk);
        }
      }

      processChunk();
    }

    function addStringRow(index, value) {
      const row = document.createElement("tr");
      const original = document.createElement("td");
      const modified = document.createElement("td");
      const input = document.createElement("input");
      input.type = "text";
      input.value = value;
      input.dataset.index = index;
      input.addEventListener("input", (e) => {
        modifiedStrings[index] = e.target.value;
      });

      original.textContent = value;
      modified.appendChild(input);
      row.appendChild(original);
      row.appendChild(modified);
      stringTable.appendChild(row);
    }

    function updateProgress(val) {
      progressBar.value = val;
      progressText.textContent = val.toFixed(1) + "%";
    }

    searchInput.addEventListener("input", () => {
      const searchVal = searchInput.value;
      for (const row of stringTable.rows) {
        const cellText = row.cells[0].textContent;
        row.style.display = (searchVal && !cellText.includes(searchVal)) ? "none" : "";
      }
    });

    saveBtn.addEventListener("click", () => {
      const newBuffer = new Uint8Array(originalBuffer.byteLength + 1000000); // Allocate space for appended
      newBuffer.set(new Uint8Array(originalBuffer));
      let newOffset = originalBuffer.byteLength;

      for (const item of stringLiterals) {
        const index = item.index;
        if (!(index in modifiedStrings)) continue;

        const modified = modifiedStrings[index];
        const original = item.value;

        const encoded = TEXT_ENCODER.encode(modified);
        const entryOffset = view.getUint32(0x54, true) + index * 8;

        if (encoded.length <= item.length) {
          newBuffer.set(encoded, item.offset);
        } else {
          newBuffer.set(encoded, newOffset);
          new DataView(newBuffer.buffer).setUint32(entryOffset, newOffset, true);
          new DataView(newBuffer.buffer).setUint32(entryOffset + 4, encoded.length, true);
          newOffset += encoded.length;
        }
      }

      const blob = new Blob([newBuffer.slice(0, newOffset)], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "modified-global-metadata.dat";
      a.click();
    });
  </script>
</body>
</html>
