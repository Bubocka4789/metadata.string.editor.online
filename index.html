<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #version {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 0.75em;
    color: #888;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn">Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.3.0</div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th style="width: 5%;">Index</th><th style="width: 45%;">Original String</th><th style="width: 50%;">Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer;
  let dataView;
  let stringLiterals = [];
  let fallbackMode = false;
  let fileName = "modified-global-metadata.dat";

  const isPrintableAscii = (str) => /^[\x20-\x7E]+$/.test(str);

  const updateProgress = (ratio) => {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  };

  const renderBatchStrings = (startIndex, batchSize) => {
    const frag = document.createDocumentFragment();
    const endIndex = Math.min(startIndex + batchSize, stringLiterals.length);
    for (let i = startIndex; i < endIndex; i++) {
      const s = stringLiterals[i];
      const tr = document.createElement('tr');
      const tdIndex = document.createElement('td');
      tdIndex.textContent = s.index;
      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.value = s.modified;
      input.addEventListener('input', e => s.modified = e.target.value);
      tdMod.appendChild(input);
      tr.appendChild(tdIndex);
      tr.appendChild(tdOrig);
      tr.appendChild(tdMod);
      frag.appendChild(tr);
    }
    tableBody.appendChild(frag);
    return endIndex;
  };

  const renderFiltered = () => {
    const filter = searchInput.value;
    tableBody.innerHTML = '';
    let idx = 0, batchSize = 100;
    const renderNext = () => {
      let rendered = 0;
      while (idx < stringLiterals.length && rendered < batchSize) {
        const s = stringLiterals[idx++];
        if (!filter || s.original.includes(filter) || s.modified.includes(filter)) {
          renderBatchStrings(idx - 1, 1);
          rendered++;
        }
      }
      if (idx < stringLiterals.length) setTimeout(renderNext, 10);
    };
    renderNext();
  };

  const fallbackStringScan = async () => {
    const u8 = new Uint8Array(arrayBuffer);
    stringLiterals = [];
    let idx = 0;
    for (let i = 0; i < u8.length;) {
      let start = i;
      while (i < u8.length && u8[i] >= 32 && u8[i] <= 126) i++;
      const len = i - start;
      if (len >= 4 && len <= 256) {
        const str = new TextDecoder().decode(u8.slice(start, i));
        stringLiterals.push({ index: idx++, offset: start, length: len, original: str, modified: str });
        if (idx % 50 === 0) {
          renderBatchStrings(idx - 50, 50);
          updateProgress(i / u8.length);
          await new Promise(r => setTimeout(r));
        }
      }
      i++;
    }
    renderBatchStrings(stringLiterals.length - 50, 50);
    updateProgress(1);
    fallbackMode = true;
    saveBtn.disabled = true;
  };

  const parseStringLiterals = async () => {
    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);
    const magic = dataView.getUint32(0, true);
    if (magic !== 0xFAB11BAF) return alert("Invalid metadata file.");

    const stringLiteralOffset = dataView.getUint32(88, true);
    const stringLiteralCount = dataView.getUint32(92, true);
    const stringLiteralDataOffset = dataView.getUint32(96, true);
    const stringLiteralDataSize = dataView.getUint32(100, true);

    if (stringLiteralOffset + stringLiteralCount * 8 > u8.length || stringLiteralDataOffset + stringLiteralDataSize > u8.length) {
      return fallbackStringScan();
    }

    stringLiterals = [];
    for (let i = 0; i < stringLiteralCount; i++) {
      const entryOffset = stringLiteralOffset + i * 8;
      const relativeOffset = dataView.getUint32(entryOffset, true);
      const length = dataView.getUint32(entryOffset + 4, true);
      const absOffset = stringLiteralDataOffset + relativeOffset;
      if (absOffset + length > u8.length) continue;
      const str = new TextDecoder().decode(u8.slice(absOffset, absOffset + length));
      if (isPrintableAscii(str)) {
        stringLiterals.push({ index: i, offset: absOffset, length, original: str, modified: str });
      }
    }
    updateProgress(1);
    renderBatchStrings(0, 100);
    saveBtn.disabled = false;
    fallbackMode = false;
  };

  const saveModifiedFile = () => {
    const u8 = new Uint8Array(arrayBuffer);
    stringLiterals.forEach(s => {
      if (s.modified === s.original) return;
      const modBytes = new TextEncoder().encode(s.modified);
      if (modBytes.length <= s.length) {
        u8.set(modBytes, s.offset);
        for (let j = modBytes.length; j < s.length; j++) u8[s.offset + j] = 0;
      } else {
        console.warn(`String at ${s.index} too long; truncating.`);
        u8.set(modBytes.slice(0, s.length), s.offset);
      }
    });
    const blob = new Blob([u8], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();
    URL.revokeObjectURL(url);
  };

  fileInput.addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    fileName = "modified-" + file.name;
    const reader = new FileReader();
    reader.onload = async () => {
      arrayBuffer = reader.result;
      await parseStringLiterals();
    };
    reader.readAsArrayBuffer(file);
  });

  searchInput.addEventListener('input', renderFiltered);
  saveBtn.addEventListener('click', saveModifiedFile);
})();
</script>
</body>
</html>
