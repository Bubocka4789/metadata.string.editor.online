<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MetaDataStringEditor Web Clone</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; display: flex; align-items: center; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    flex-grow: 1;
    height: 20px; background: #333; margin: 0 1em 0 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
    transition: width 0.2s ease;
  }
  #search {
    width: 300px; padding: 0.3em; margin-left: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-word;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #versionLabel {
    position: fixed;
    top: 4px;
    right: 6px;
    font-size: 10px;
    color: #666;
    user-select: none;
    pointer-events: none;
  }
  button:disabled {
    opacity: 0.4;
    cursor: default;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <input type="text" id="search" placeholder="Case-sensitive search..." />
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th style="width:120px;">Offset (hex)</th><th style="width:50%;">Original String</th><th>Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>
<div id="versionLabel">Version: 1.0.0 (web clone)</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer;
  let dataView;
  let stringLiteralCount = 0;
  let stringLiteralOffset = 0;
  let stringLiterals = []; // { offset, length, original, modified }
  let modifiedCount = 0;

  // Helper: read ASCII/UTF8 string from offset & length
  function readString(offset, length) {
    if (offset + length > dataView.byteLength) return '';
    let chars = [];
    for (let i = 0; i < length; i++) {
      const byte = dataView.getUint8(offset + i);
      // Accept ASCII printable + space + common extended chars
      if (byte >= 32 && byte <= 126) {
        chars.push(String.fromCharCode(byte));
      } else {
        chars.push(' ');
      }
    }
    return chars.join('');
  }

  // Enhanced detection for string literal count & offset, Gorilla Tag friendly + fallback scan
  function detectStringLiteralTableOffsets() {
    try {
      // Try Gorilla Tag known version offsets first (versions 24 or 27)
      const version = dataView.getUint32(0x0, true);
      if (version === 24 || version === 27) {
        const count = dataView.getUint32(0x50, true);
        const offset = dataView.getUint32(0x54, true);
        if (
          count > 0 &&
          offset > 0 &&
          offset + count * 8 <= arrayBuffer.byteLength &&
          count < 10_000_000
        ) {
          return { count, offset };
        }
      }
    } catch (e) {}

    // Try known alternate offsets from other Unity versions
    const candidates = [
      { count: 0x50, offset: 0x54 },
      { count: 0x58, offset: 0x5C },
      { count: 0x40, offset: 0x44 }
    ];
    for (const c of candidates) {
      try {
        if (arrayBuffer.byteLength > c.offset + 4) {
          const count = dataView.getUint32(c.count, true);
          const offset = dataView.getUint32(c.offset, true);
          if (
            count > 0 &&
            offset > 0 &&
            offset + count * 8 <= arrayBuffer.byteLength &&
            count < 10_000_000
          ) {
            return { count, offset };
          }
        }
      } catch (e) {}
    }

    // Fallback scan: scan 0x20..0x100 for plausible (count, offset) pairs
    for (let pos = 0x20; pos < 0x100; pos += 4) {
      try {
        const count = dataView.getUint32(pos, true);
        const offset = dataView.getUint32(pos + 4, true);
        if (
          count > 0 &&
          offset > 0 &&
          offset + count * 8 <= arrayBuffer.byteLength &&
          count < 10_000_000 &&
          offset < arrayBuffer.byteLength
        ) {
          // Sanity check: offset points inside file and first string offset valid
          if (dataView.getUint32(offset, true) < arrayBuffer.byteLength) {
            return { count, offset };
          }
        }
      } catch (e) {
        // ignore read errors
      }
    }
    return null;
  }

  // Extract string literals incrementally in batches (to avoid freeze)
  async function extractStrings(batchSize = 200) {
    stringLiterals = [];
    let extracted = 0;
    while (extracted < stringLiteralCount) {
      let batchEnd = Math.min(extracted + batchSize, stringLiteralCount);
      for (let i = extracted; i < batchEnd; i++) {
        const entryOffset = stringLiteralOffset + i * 8;
        if (entryOffset + 8 > dataView.byteLength) break;
        const stringOffset = dataView.getUint32(entryOffset, true);
        const stringLength = dataView.getInt32(entryOffset + 4, true);
        if (
          stringOffset > 0 &&
          stringLength > 0 &&
          stringOffset + stringLength <= arrayBuffer.byteLength
        ) {
          const original = readString(stringOffset, stringLength);
          stringLiterals.push({
            offset: stringOffset,
            length: stringLength,
            original,
            modified: original
          });
        }
      }
      extracted = batchEnd;
      updateTable();
      updateProgress(extracted / stringLiteralCount);
      await new Promise(r => setTimeout(r, 0)); // yield to UI to avoid freeze
    }
    updateProgress(1);
    saveBtn.disabled = false;
  }

  // Render the table rows filtered by search term (case-sensitive)
  function updateTable() {
    const filter = searchInput.value;
    tableBody.innerHTML = '';
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < stringLiterals.length; i++) {
      const s = stringLiterals[i];
      if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;
      const tr = document.createElement('tr');
      // Offset hex
      const tdOff = document.createElement('td');
      tdOff.textContent = '0x' + s.offset.toString(16).toUpperCase().padStart(8, '0');
      tr.appendChild(tdOff);
      // Original string
      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      tr.appendChild(tdOrig);
      // Modified string (editable)
      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.spellcheck = false;
      input.addEventListener('input', e => {
        s.modified = e.target.value;
        if (s.modified !== s.original) {
          tr.style.backgroundColor = '#440000';
          modifiedCount++;
        } else {
          tr.style.backgroundColor = '';
          modifiedCount = Math.max(0, modifiedCount - 1);
        }
      });
      tdMod.appendChild(input);
      tr.appendChild(tdMod);
      fragment.appendChild(tr);
    }
    tableBody.appendChild(fragment);
  }

  // Update progress bar
  function updateProgress(fraction) {
    progressBar.style.width = (fraction * 100).toFixed(2) + '%';
  }

  // Save modified metadata.dat
  function saveModifiedFile() {
    const outBuffer = new Uint8Array(arrayBuffer.slice(0));
    // Overwrite or append modified strings
    let appendPos = outBuffer.length;
    for (let i = 0; i < stringLiterals.length; i++) {
      const s = stringLiterals[i];
      if (s.modified === s.original) continue;
      // Encode new string as UTF8-like ASCII (only ASCII range)
      const encoded = new TextEncoder().encode(s.modified);
      if (encoded.length <= s.length) {
        // Overwrite in place, pad with spaces if shorter
        for (let j = 0; j < encoded.length; j++) outBuffer[s.offset + j] = encoded[j];
        for (let j = encoded.length; j < s.length; j++) outBuffer[s.offset + j] = 0x20;
      } else {
        // Append new string at appendPos
        const newOffset = appendPos;
        if (newOffset + encoded.length > outBuffer.length) {
          // Resize output buffer if needed
          const tmp = new Uint8Array(newOffset + encoded.length);
          tmp.set(outBuffer);
          outBuffer.set(tmp);
        }
        for (let j = 0; j < encoded.length; j++) outBuffer[newOffset + j] = encoded[j];
        // Pad with spaces if needed
        for (let j = encoded.length; j < s.length; j++) outBuffer[newOffset + j] = 0x20;
        // Update string offset in literal table (8 bytes per entry)
        const entryOffset = stringLiteralOffset + i * 8;
        const dvOut = new DataView(outBuffer.buffer);
        dvOut.setUint32(entryOffset, newOffset, true);
        // Update string length to new length (4 bytes after offset)
        dvOut.setInt32(entryOffset + 4, encoded.length, true);
        appendPos += encoded.length;
      }
    }
    // Trigger download
    const blob = new Blob([outBuffer], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'global-metadata-modified.dat';
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
  }

  fileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    progressBar.style.width = '0%';
    saveBtn.disabled = true;
    tableBody.innerHTML = '';
    stringLiterals = [];
    modifiedCount = 0;
    const reader = new FileReader();
    reader.onload = () => {
      arrayBuffer = reader.result;
      dataView = new DataView(arrayBuffer);
      const detected = detectStringLiteralTableOffsets();
      if (!detected) {
        alert('Failed to detect Il2CppStringLiteral table offsets.\nMake sure this is a valid global-metadata.dat file.');
        return;
      }
      stringLiteralCount = detected.count;
      stringLiteralOffset = detected.offset;
      extractStrings();
    };
    reader.readAsArrayBuffer(file);
  });

  searchInput.addEventListener('input', () => {
    updateTable();
  });

  saveBtn.addEventListener('click', () => {
    saveModifiedFile();
  });

})();
</script>
</body>
</html>
