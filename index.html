<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Il2Cpp Metadata String Editor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f2f2f2;
      color: #000;
    }

    body.dark-mode {
      background-color: #121212;
      color: #ddd;
    }

    #controls {
      display: flex;
      padding: 10px;
      gap: 10px;
      background-color: #e0e0e0;
    }

    body.dark-mode #controls {
      background-color: #1e1e1e;
    }

    #output {
      max-height: 80vh;
      overflow-y: auto;
      padding: 10px;
    }

    .row {
      display: flex;
      gap: 10px;
      margin-bottom: 4px;
      align-items: center;
    }

    .row span {
      flex: 0 0 50px;
    }

    .row input {
      flex: 1;
      padding: 4px;
    }

    button {
      padding: 5px 10px;
    }

    #progress {
      margin-top: 5px;
    }

    #search {
      padding: 5px;
      width: 200px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="fileInput" />
    <button onclick="downloadDAT()">Save .dat</button>
    <button onclick="downloadIDE()">Save .ide</button>
    <input id="search" type="text" placeholder="Search..." />
    <button onclick="toggleDarkMode()">ðŸŒ™</button>
  </div>
  <div id="progress"></div>
  <div id="output"></div>

  <script>
    let strings = [];
    let modified = new Map();
    let fileData = null;
    let originalFile = null;

    const fileInput = document.getElementById('fileInput');
    const output = document.getElementById('output');
    const progress = document.getElementById('progress');
    const searchInput = document.getElementById('search');

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async function () {
        fileData = new Uint8Array(reader.result);
        originalFile = fileData.slice();
        parseMetadata(fileData);
      };
      reader.readAsArrayBuffer(file);
    });

    searchInput.addEventListener('input', () => {
      renderStrings(searchInput.value.toLowerCase());
    });

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
    }

    function parseMetadata(bytes) {
      const magic = new DataView(bytes.buffer).getUint32(0, true);
      const version = new DataView(bytes.buffer).getInt32(4, true);
      if (magic !== 0xFAB11BAF && magic !== 0xFAB11BFA) {
        alert("Invalid metadata file.");
        return;
      }

      const stringLiteralOffset = new DataView(bytes.buffer).getUint32(0x30, true);
      const stringLiteralCount = new DataView(bytes.buffer).getUint32(0x34, true);

      if (stringLiteralCount > 1000000) {
        alert("Warning: Very large string literal count. Will only load first 10,000 for performance.");
      }

      strings = [];
      const limit = Math.min(stringLiteralCount, 10000);

      const view = new DataView(bytes.buffer);

      for (let i = 0; i < limit; i++) {
        const entryOffset = stringLiteralOffset + i * 8;
        const dataOffset = view.getUint32(entryOffset, true);
        const length = view.getUint32(entryOffset + 4, true);
        if (dataOffset === 0 || length === 0) continue;

        const stringBytes = bytes.slice(dataOffset, dataOffset + length);
        try {
          const decoded = new TextDecoder("utf-8").decode(stringBytes);
          if (/^[\x20-\x7E\s]{1,200}$/.test(decoded)) {
            strings.push({ index: i, offset: dataOffset, length, value: decoded });
          }
        } catch {}
      }

      renderStrings();
    }

    function renderStrings(filter = '') {
      output.innerHTML = '';
      const fragment = document.createDocumentFragment();
      let shown = 0;

      for (const entry of strings) {
        if (filter && !entry.value.toLowerCase().includes(filter)) continue;

        const row = document.createElement('div');
        row.className = 'row';

        const indexSpan = document.createElement('span');
        indexSpan.textContent = entry.index;
        row.appendChild(indexSpan);

        const input = document.createElement('input');
        input.value = modified.has(entry.index) ? modified.get(entry.index) : entry.value;
        input.addEventListener('input', () => {
          modified.set(entry.index, input.value);
        });
        row.appendChild(input);

        fragment.appendChild(row);
        shown++;
        if (shown > 1000) break; // limit on render per pass
      }

      output.appendChild(fragment);
      progress.textContent = `Showing ${shown} of ${strings.length} strings.`;
    }

    function downloadDAT() {
      if (!originalFile) return;

      const newData = new Uint8Array(originalFile.length + 1000000);
      newData.set(originalFile);
      let appendOffset = originalFile.length;
      const view = new DataView(newData.buffer);

      for (const entry of strings) {
        if (!modified.has(entry.index)) continue;
        const newString = modified.get(entry.index);
        const encoded = new TextEncoder().encode(newString);
        const stringLiteralOffset = 0x30;
        const entryOffset = new DataView(originalFile.buffer).getUint32(stringLiteralOffset, true) + entry.index * 8;

        view.setUint32(entryOffset, appendOffset, true);
        view.setUint32(entryOffset + 4, encoded.length, true);
        newData.set(encoded, appendOffset);
        appendOffset += encoded.length;
      }

      const blob = new Blob([newData.slice(0, appendOffset)], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'global-metadata-edited.dat';
      a.click();
    }

    function downloadIDE() {
      const output = [];
      for (const entry of strings) {
        if (modified.has(entry.index)) {
          output.push(`#${entry.index}\n${modified.get(entry.index)}\n`);
        }
      }

      const blob = new Blob([output.join('\n')], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'strings.ide';
      a.click();
    }
  </script>
</body>
</html>
