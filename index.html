<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #version {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 0.75em;
    color: #888;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.1.0</div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th>Index</th><th>Original String</th><th>Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer;
  let dataView;
  let stringLiterals = [];
  let stringLiteralOffset = 0;
  let stringLiteralCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;
  let fallbackMode = false; // fallback brute-force string scan mode

  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  function updateTable() {
    const filter = searchInput.value;
    tableBody.innerHTML = '';
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < stringLiterals.length; i++) {
      const s = stringLiterals[i];
      if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;
      const tr = document.createElement('tr');
      const tdIndex = document.createElement('td');
      tdIndex.textContent = s.index;
      tr.appendChild(tdIndex);
      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      tr.appendChild(tdOrig);
      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.spellcheck = false;
      input.addEventListener('input', e => {
        s.modified = e.target.value;
      });
      tdMod.appendChild(input);
      tr.appendChild(tdMod);
      fragment.appendChild(tr);
    }
    tableBody.appendChild(fragment);
  }

  function saveModifiedFile() {
    if (fallbackMode) {
      alert('Save is disabled in fallback mode (no metadata offsets to patch).');
      return;
    }
    let newBuffer = new Uint8Array(arrayBuffer);
    let dv = new DataView(newBuffer.buffer);
    let dataEnd = stringLiteralDataOffset + stringLiteralDataSize;
    for (const s of stringLiterals) {
      if (s.modified === s.original) continue;
      const encoded = new TextEncoder().encode(s.modified);
      if (encoded.length <= s.length) {
        for (let i = 0; i < encoded.length; i++) newBuffer[s.offset + i] = encoded[i];
        for (let i = encoded.length; i < s.length; i++) newBuffer[s.offset + i] = 0;
      } else {
        // Append to end
        const newOffset = dataEnd;
        for (let i = 0; i < encoded.length; i++) newBuffer[newOffset + i] = encoded[i];
        dataEnd += encoded.length;
        // Update offset and length in string literal table
        dv.setUint32(stringLiteralOffset + s.index * 8, newOffset - stringLiteralDataOffset, true);
        dv.setUint32(stringLiteralOffset + s.index * 8 + 4, encoded.length, true);
      }
    }
    const blob = new Blob([newBuffer.slice(0, dataEnd)], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'global-metadata.modified.dat';
    a.click();
    URL.revokeObjectURL(url);
  }

  function isPrintableAscii(str) {
    // At least 1 char, and all chars between 32 and 126 inclusive (printable ASCII + space)
    if (!str) return false;
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c < 32 || c > 126) return false;
    }
    return true;
  }

  async function fallbackStringScan() {
    // Simple brute-force scan for ASCII printable strings of length >= 4
    // Show progress as we scan the entire file
    stringLiterals = [];
    const u8 = new Uint8Array(arrayBuffer);
    let idx = 0;
    let pos = 0;
    const minLen = 4;
    const maxLen = 256;

    while (pos < u8.length) {
      let start = pos;
      while (pos < u8.length && u8[pos] >= 32 && u8[pos] <= 126) {
        pos++;
        if (pos - start > maxLen) break; // max length limit
      }
      const len = pos - start;
      if (len >= minLen) {
        const bytes = u8.slice(start, pos);
        const str = new TextDecoder().decode(bytes);
        if (isPrintableAscii(str)) {
          stringLiterals.push({ index: idx++, offset: start, length: len, original: str, modified: str });
          if (idx % 100 === 0) {
            updateProgress(pos / u8.length);
            await new Promise(r => setTimeout(r, 0));
          }
        }
      }
      pos++;
    }
    updateProgress(1);
    saveBtn.disabled = true; // disable save because no metadata offsets to patch
    updateTable();
  }

  async function parseStringLiterals() {
    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);

    // Check magic number
    const magic = dataView.getUint32(0, true);
    if (magic !== 0xFAB11BAF) {
      alert('Invalid global-metadata.dat file (bad magic number).');
      return;
    }

    // Read version
    const version = dataView.getUint32(12, true);

    // Read string literal offsets and counts from header (common offsets for Unity metadata v24+)
    // For some files these offsets may differ, adjust if needed
    stringLiteralOffset = dataView.getUint32(88, true);
    stringLiteralCount = dataView.getUint32(92, true);
    stringLiteralDataOffset = dataView.getUint32(96, true);
    stringLiteralDataSize = dataView.getUint32(100, true);

    // Basic sanity checks to avoid out-of-bounds errors
    if (stringLiteralOffset + stringLiteralCount * 8 > u8.length) {
      console.warn('String literal table exceeds file size or invalid.');
      fallbackMode = true;
      await fallbackStringScan();
      return;
    }
    if (stringLiteralDataOffset + stringLiteralDataSize > u8.length) {
      console.warn('String literal data block exceeds file size or invalid.');
      fallbackMode = true;
      await fallbackStringScan();
      return;
    }

    // Parse string literal entries
    stringLiterals = [];
    for (let i = 0; i < stringLiteralCount; i++) {
      const entryOffset = stringLiteralOffset + i * 8;
      const relativeOffset = dataView.getUint32(entryOffset, true);
      const length = dataView.getUint32(entryOffset + 4, true);
      const absoluteOffset = stringLiteralDataOffset + relativeOffset;

      if (absoluteOffset + length > u8.length) {
        // Skip invalid entries
        console.warn(`Skipping invalid string literal #${i}: out of bounds.`);
        continue;
      }

      const bytes = u8.slice(absoluteOffset, absoluteOffset + length);
      const str = new TextDecoder().decode(bytes);

      // Skip non-printable or empty strings (optional)
      if (!str || !isPrintableAscii(str)) {
        continue;
      }

      stringLiterals.push({ index: i, offset: absoluteOffset, length, original: str, modified: str });

      // Show progress every 500 strings to keep UI responsive
      if (i % 500 === 0) {
        updateProgress(i / stringLiteralCount);
        await new Promise(r => setTimeout(r, 0));
      }
    }
    updateProgress(1);
    fallbackMode = false;
    saveBtn.disabled = false;
    updateTable();
  }

  fileInput.addEventListener('change', async (e) => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = async () => {
      arrayBuffer = reader.result;
      await parseStringLiterals();
    };
    reader.readAsArrayBuffer(file);
  });

  searchInput.addEventListener('input', () => {
    updateTable();
  });

  saveBtn.addEventListener('click', () => {
    saveModifiedFile();
  });

})();
</script>
</body>
</html>
