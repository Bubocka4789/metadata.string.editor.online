<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor - VR Metadata Friendly</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
    transition: width 0.3s ease;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #version {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 0.75em;
    color: #888;
  }
  #status {
    position: absolute;
    left: 10px;
    bottom: 5px;
    font-size: 0.8em;
    color: #999;
    user-select: none;
  }
  button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.4.1 VR friendly</div>
  <div id="status"></div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th style="width: 5%;">Index</th><th style="width: 45%;">Original String</th><th style="width: 50%;">Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');
  const status = document.getElementById('status');

  let arrayBuffer;
  let dataView;
  let stringLiterals = [];
  let stringLiteralOffset = 0;
  let stringLiteralCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;
  let fileName = '';

  // Configurable batch size for incremental rendering
  const BATCH_SIZE = 500;

  // Utility: update progress bar width [0..1]
  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  // Utility: check if bytes likely represent a printable ASCII string (with spaces)
  function isLikelyString(bytes) {
    for (let b of bytes) {
      if (b === 0) continue; // null terminator
      // allow ASCII printable + space + common punctuation
      if (b < 32 || b > 126) return false;
    }
    return true;
  }

  // Incremental rendering to avoid UI freezing
  async function renderFilteredIncremental() {
    const filter = searchInput.value;
    tableBody.innerHTML = '';
    updateProgress(0);
    let matched = 0;

    // Process in batches asynchronously
    for (let start = 0; start < stringLiterals.length; start += BATCH_SIZE) {
      const frag = document.createDocumentFragment();
      const end = Math.min(start + BATCH_SIZE, stringLiterals.length);
      for (let i = start; i < end; i++) {
        const s = stringLiterals[i];
        if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;

        const tr = document.createElement('tr');
        const tdIndex = document.createElement('td');
        tdIndex.textContent = s.index;
        tr.appendChild(tdIndex);

        const tdOrig = document.createElement('td');
        tdOrig.textContent = s.original;
        tr.appendChild(tdOrig);

        const tdMod = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.value = s.modified;
        input.spellcheck = false;
        input.autocomplete = 'off';
        input.addEventListener('input', e => {
          s.modified = e.target.value;
          saveBtn.disabled = !stringLiterals.some(x => x.original !== x.modified);
          status.textContent = 'Editing...';
        });
        tdMod.appendChild(input);
        tr.appendChild(tdMod);

        frag.appendChild(tr);
        matched++;
      }
      tableBody.appendChild(frag);
      updateProgress(start / stringLiterals.length);

      // Yield control to keep UI responsive
      await new Promise(r => setTimeout(r, 10));
    }
    updateProgress(1);
    status.textContent = `${matched} strings displayed.`;
  }

  // Parsing the string literals table and strings data WITHOUT magic header check
  async function parseStringLiterals() {
    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);

    // Read offsets & counts from the header (these positions assumed as per Il2Cpp spec)
    stringLiteralOffset = dataView.getUint32(88, true);
    stringLiteralCount = dataView.getUint32(92, true);
    stringLiteralDataOffset = dataView.getUint32(96, true);
    stringLiteralDataSize = dataView.getUint32(100, true);

    // Validate basic bounds; silently skip invalid file instead of alert to prevent freezing or blocking
    if (
      stringLiteralOffset === 0 || stringLiteralCount === 0 ||
      stringLiteralDataOffset === 0 || stringLiteralDataSize === 0 ||
      stringLiteralOffset + stringLiteralCount * 8 > u8.length ||
      stringLiteralDataOffset + stringLiteralDataSize > u8.length
    ) {
      status.textContent = 'Warning: Metadata header fields invalid or file truncated.';
      saveBtn.disabled = true;
      return;
    }

    stringLiterals = [];

    // Parse each string literal entry: (relative offset, length)
    for (let i = 0; i < stringLiteralCount; i++) {
      const entryOffset = stringLiteralOffset + i * 8;
      const relOffset = dataView.getUint32(entryOffset, true);
      const length = dataView.getUint32(entryOffset + 4, true);
      const absOffset = stringLiteralDataOffset + relOffset;

      // Check bounds & valid string data
      if (absOffset + length > u8.length || length <= 0) continue;

      const bytes = u8.slice(absOffset, absOffset + length);
      const nullTerminated = bytes.indexOf(0);
      const cleanBytes = nullTerminated !== -1 ? bytes.slice(0, nullTerminated) : bytes;
      if (!isLikelyString(cleanBytes)) continue;

      const str = new TextDecoder().decode(cleanBytes);
      stringLiterals.push({ index: i, offset: entryOffset, length, original: str, modified: str });
    }

    status.textContent = `Loaded ${stringLiterals.length} strings.`;
    saveBtn.disabled = true;
    await renderFilteredIncremental();
    saveBtn.disabled = false;
  }

  fileInput.addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    fileName = file.name;
    status.textContent = 'Loading file...';
    saveBtn.disabled = true;
    progressBar.style.width = '0%';

    try {
      const reader = new FileReader();
      reader.onload = async () => {
        arrayBuffer = reader.result;
        await parseStringLiterals();
      };
      reader.readAsArrayBuffer(file);
    } catch (ex) {
      status.textContent = `Error reading file: ${ex.message}`;
      saveBtn.disabled = true;
    }
  });

  searchInput.addEventListener('input', () => {
    status.textContent = 'Filtering...';
    renderFilteredIncremental();
  });

  saveBtn.addEventListener('click', () => {
    const modifiedStrings = stringLiterals.filter(s => s.original !== s.modified);
    if (!modifiedStrings.length) {
      alert('No changes to save.');
      return;
    }

    // Prepare new Uint8Arrays for building output
    const oldBytes = new Uint8Array(arrayBuffer);
    let appendOffset = oldBytes.length;

    // Create new string literal table (count * 8 bytes)
    const newTableBytes = new Uint8Array(stringLiteralCount * 8);
    const newTableView = new DataView(newTableBytes.buffer);

    // Array of { offset, bytes } chunks for appended modified strings
    const appendedStrings = [];

    for (let s of stringLiterals) {
      let offset, length;
      if (s.original !== s.modified) {
        // Modified string - encode and append to end
        const encoded = new TextEncoder().encode(s.modified);
        offset = appendOffset - stringLiteralDataOffset;
        length = encoded.length;
        appendedStrings.push({ offset: appendOffset, bytes: encoded });
        appendOffset += length;
      } else {
        // Original string - keep existing offset & length
        offset = dataView.getUint32(s.offset, true);
        length = s.length;
      }
      // Update new string literal table entry
      newTableView.setUint32(s.index * 8, offset, true);
      newTableView.setUint32(s.index * 8 + 4, length, true);
    }

    // Build final file Uint8Array (old file + appended strings + new string literal table)
    const finalLength = appendOffset;
    const finalFile = new Uint8Array(finalLength);

    // Copy old file
    finalFile.set(oldBytes, 0);

    // Copy appended modified strings at their offsets
    for (let chunk of appendedStrings) {
      finalFile.set(chunk.bytes, chunk.offset);
    }

    // Overwrite the string literal table at original offset
    finalFile.set(newTableBytes, stringLiteralOffset);

    // Trigger file download
    const blob = new Blob([finalFile], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName.replace(/\.dat$/, '') + '_modded.dat';
    a.click();
    URL.revokeObjectURL(url);

    status.textContent = 'File saved successfully.';
    saveBtn.disabled = true;
  });
})();
</script>
</body>
</html>
