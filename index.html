<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #version {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 0.75em;
    color: #888;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.2.0</div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th style="width: 5%;">Index</th><th style="width: 45%;">Original String</th><th style="width: 50%;">Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer;
  let dataView;
  let stringLiterals = [];
  let stringLiteralOffset = 0;
  let stringLiteralCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;
  let fallbackMode = false; // fallback brute-force string scan mode

  let filter = '';

  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  function isPrintableAscii(str) {
    if (!str) return false;
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c < 32 || c > 126) return false;
    }
    return true;
  }

  // Renders currently loaded string literals that pass the current filter.
  // Renders only incremental updates (for performance)
  function renderBatchStrings(startIndex, batchSize) {
    const frag = document.createDocumentFragment();
    const endIndex = Math.min(startIndex + batchSize, stringLiterals.length);
    for (let i = startIndex; i < endIndex; i++) {
      const s = stringLiterals[i];
      if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;
      const tr = document.createElement('tr');
      const tdIndex = document.createElement('td');
      tdIndex.textContent = s.index;
      tr.appendChild(tdIndex);

      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      tr.appendChild(tdOrig);

      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.spellcheck = false;
      input.addEventListener('input', e => {
        s.modified = e.target.value;
      });
      tdMod.appendChild(input);
      tr.appendChild(tdMod);

      frag.appendChild(tr);
    }
    tableBody.appendChild(frag);
    return endIndex;
  }

  // Full render when search changes: clears & re-renders all matching strings.
  function renderFiltered() {
    tableBody.innerHTML = '';
    filter = searchInput.value;
    let idx = 0;
    const batchSize = 100;
    function renderNextBatch() {
      let rendered = 0;
      while (idx < stringLiterals.length && rendered < batchSize) {
        const s = stringLiterals[idx];
        if (!filter || s.original.includes(filter) || s.modified.includes(filter)) {
          const tr = document.createElement('tr');
          const tdIndex = document.createElement('td');
          tdIndex.textContent = s.index;
          tr.appendChild(tdIndex);

          const tdOrig = document.createElement('td');
          tdOrig.textContent = s.original;
          tr.appendChild(tdOrig);

          const tdMod = document.createElement('td');
          const input = document.createElement('input');
          input.type = 'text';
          input.value = s.modified;
          input.spellcheck = false;
          input.addEventListener('input', e => {
            s.modified = e.target.value;
          });
          tdMod.appendChild(input);
          tr.appendChild(tdMod);

          tableBody.appendChild(tr);
          rendered++;
        }
        idx++;
      }
      if (idx < stringLiterals.length) {
        setTimeout(renderNextBatch, 10);
      }
    }
    renderNextBatch();
  }

  async function fallbackStringScan() {
    stringLiterals = [];
    const u8 = new Uint8Array(arrayBuffer);
    let idx = 0;
    let pos = 0;
    const minLen = 4;
    const maxLen = 256;

    tableBody.innerHTML = '';
    saveBtn.disabled = true;

    while (pos < u8.length) {
      let start = pos;
      while (pos < u8.length && u8[pos] >= 32 && u8[pos] <= 126) {
        pos++;
        if (pos - start > maxLen) break;
      }
      const len = pos - start;
      if (len >= minLen) {
        const bytes = u8.slice(start, pos);
        const str = new TextDecoder().decode(bytes);
        if (isPrintableAscii(str)) {
          stringLiterals.push({ index: idx++, offset: start, length: len, original: str, modified: str });

          // Render last inserted string live to UI:
          if (idx % 50 === 0) {
            renderBatchStrings(idx - 50, 50);
            updateProgress(pos / u8.length);
            await new Promise(r => setTimeout(r, 0));
          }
        }
      }
      pos++;
    }
    renderBatchStrings(idx - 50, 50);
    updateProgress(1);
    fallbackMode = true;
  }

  async function parseStringLiterals() {
    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);

    const magic = dataView.getUint32(0, true);
    if (magic !== 0xFAB11BAF) {
      alert('Invalid global-metadata.dat file (bad magic number).');
      return;
    }

    stringLiteralOffset = dataView.getUint32(88, true);
    stringLiteralCount = dataView.getUint32(92, true);
    stringLiteralDataOffset = dataView.getUint32(96, true);
    stringLiteralDataSize = dataView.getUint32(100, true);

    if (stringLiteralOffset + stringLiteralCount * 8 > u8.length || stringLiteralDataOffset + stringLiteralDataSize > u8.length) {
      console.warn('String literal table or data exceeds file size or invalid.');
      fallbackMode = true;
      await fallbackStringScan();
      return;
    }

    stringLiterals = [];
    tableBody.innerHTML = '';
    saveBtn.disabled = false;

    let parsedCount = 0;
    const batchSize = 500;

    while (parsedCount < stringLiteralCount) {
      const end = Math.min(parsedCount + batchSize, stringLiteralCount);
      for (let i = parsedCount; i < end; i++) {
        const entryOffset = stringLiteralOffset + i * 8;
        const relativeOffset = dataView.getUint32(entryOffset, true);
        const length = dataView.getUint32(entryOffset + 4, true);
        const absoluteOffset = stringLiteralDataOffset + relativeOffset;

        if (absoluteOffset + length > u8.length) {
          continue; // skip invalid
        }
        const bytes = u8.slice(absoluteOffset, absoluteOffset + length);
        const str = new TextDecoder().decode(bytes);
        if (!str || !isPrintableAscii(str)) continue;

        stringLiterals.push({ index: i, offset: absoluteOffset, length, original: str, modified: str });
      }

      renderBatchStrings(parsedCount, batchSize);
      parsedCount = end;
      updateProgress(parsedCount / stringLiteralCount);
      await new Promise(r => setTimeout(r, 0));
    }
    updateProgress(1);
    fallbackMode = false;
  }

  fileInput.addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = async () => {
      arrayBuffer = reader.result;
      searchInput.value = '';
      filter = '';
      await parseStringLiterals();
    };
    reader.readAsArrayBuffer(file);
  });

  searchInput.addEventListener('input', () => {
    filter = searchInput.value;
    renderFiltered();
  });

  // === REPLACED saveBtn EVENT LISTENER WITH FULL SAVE LOGIC ===
  saveBtn.addEventListener('click', () => {
    if (!arrayBuffer || !stringLiterals.length) return;
    if (fallbackMode) {
      alert('Saving is disabled in fallback scan mode.');
      return;
    }

    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);

    // We'll need a new buffer if we have to append longer strings
    let newBuffer = null;
    let newBufferView = null;

    // Calculate original string literal data region end (absolute)
    const stringLiteralDataEnd = stringLiteralDataOffset + stringLiteralDataSize;

    // Start appending at the end of original string literal data
    let appendOffset = stringLiteralDataEnd;

    for (const s of stringLiterals) {
      if (s.modified === s.original) {
        // No change: do nothing
        continue;
      }

      const originalBytes = new TextEncoder().encode(s.original);
      const modifiedBytes = new TextEncoder().encode(s.modified);

      if (modifiedBytes.length === s.length) {
        // Same length: overwrite in-place
        u8.set(modifiedBytes, s.offset);
      } else if (modifiedBytes.length < s.length) {
        // Shorter: overwrite and zero-pad the rest
        u8.set(modifiedBytes, s.offset);
        u8.fill(0, s.offset + modifiedBytes.length, s.offset + s.length);
      } else {
        // Longer: must append to newBuffer (or create if not exists)
        if (!newBuffer) {
          // Create new buffer bigger than original, enough for all appended strings
          // Let's start with original length + extra 1MB (adjust as needed)
          const extraSize = 1024 * 1024; 
          newBuffer = new Uint8Array(u8.length + extraSize);
          newBuffer.set(u8);
          newBufferView = new DataView(newBuffer.buffer);
        }

        // Write modified string at appendOffset
        newBuffer.set(modifiedBytes, appendOffset);

        // Update string literal entry: relative offset and length
        // Relative offset from stringLiteralDataOffset
        const relativeOffset = appendOffset - stringLiteralDataOffset;

        // Write updated offset and length in string literal table
        const entryOffset = stringLiteralOffset + s.index * 8;
        newBufferView.setUint32(entryOffset, relativeOffset, true);
        newBufferView.setUint32(entryOffset + 4, modifiedBytes.length, true);

        // Update append offset for next append
        appendOffset += modifiedBytes.length;

        // Update string object offset and length for future reference (not mandatory)
        s.offset = appendOffset - modifiedBytes.length;
        s.length = modifiedBytes.length;
      }
    }

    // If newBuffer is used, we must update stringLiteralDataSize field in header:
    if (newBuffer) {
      // Calculate new size
      const newSize = appendOffset - stringLiteralDataOffset;
      // Update header at offset 100
      newBufferView.setUint32(100, newSize, true);

      // Replace old buffer with new one
      arrayBuffer = newBuffer.buffer;
      dataView = newBufferView;
    }

    // If no newBuffer (no appended longer strings), update offsets/lengths in original buffer for any shorter or equal length modifications
    if (!newBuffer) {
      for (const s of stringLiterals) {
        if (s.modified !== s.original) {
          // Even if same length or shorter and already overwritten, we must update length if changed
          const modifiedBytes = new TextEncoder().encode(s.modified);
          if (modifiedBytes.length !== s.length) {
            // Write updated length in table
            const entryOffset = stringLiteralOffset + s.index * 8;
            dataView.setUint32(entryOffset + 4, modifiedBytes.length, true);

            // Zero fill remaining if shorter is already done
          }
        }
      }
    }

    // Trigger file download
    const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'global-metadata.modified.dat';
    a.click();
    URL.revokeObjectURL(url);
  });
  // === END saveBtn listener replacement ===

})();
</script>
</body>
</html>
