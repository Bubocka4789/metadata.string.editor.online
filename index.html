<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor - VR Edition</title>
<style>
  /* Dark theme and layout */
  body {
    background: #121212;
    color: #ddd;
    font-family: Consolas, monospace;
    margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column;
  }
  header {
    background: #1e1e1e;
    padding: 0.8em 1em;
    display: flex;
    align-items: center;
    gap: 1em;
  }
  input[type="file"] {
    color: #eee;
  }
  #search {
    flex-grow: 1;
    background: #2a2a2a;
    border: 1px solid #444;
    color: #eee;
    font-size: 1em;
    padding: 0.4em 0.6em;
    border-radius: 3px;
  }
  #saveBtn {
    background: #007acc;
    border: none;
    color: white;
    padding: 0.5em 1em;
    font-weight: bold;
    border-radius: 4px;
    cursor: pointer;
  }
  #saveBtn:disabled {
    background: #555;
    cursor: not-allowed;
  }
  #progressBar {
    position: relative;
    width: 100%;
    height: 16px;
    background: #222;
    border-radius: 8px;
    overflow: hidden;
    margin-top: 0.5em;
  }
  #progressBar > div {
    background: #00aaff;
    height: 100%;
    width: 0%;
    transition: width 0.2s ease;
  }
  #version {
    color: #666;
    font-size: 0.8em;
    margin-left: auto;
    user-select: none;
  }
  main {
    flex-grow: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #stringsContainer {
    flex-grow: 1;
    overflow: auto;
    background: #181818;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  thead {
    background: #222;
    position: sticky;
    top: 0;
    z-index: 2;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.3em 0.6em;
    text-align: left;
    vertical-align: top;
    color: #eee;
    overflow-wrap: break-word;
    word-break: break-word;
  }
  th {
    user-select: none;
  }
  td.indexCol {
    width: 5%;
    text-align: center;
    font-weight: bold;
  }
  td.origCol, td.modCol {
    width: 47.5%;
  }
  input.editInput {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: Consolas, monospace;
    font-size: 1em;
    outline-offset: 2px;
  }
  input.editInput:focus {
    outline: 2px solid #00aaff;
    background: #222;
  }
  /* Scrollbar styling */
  #stringsContainer::-webkit-scrollbar {
    width: 12px;
  }
  #stringsContainer::-webkit-scrollbar-thumb {
    background: #444;
    border-radius: 6px;
  }
  #stringsContainer::-webkit-scrollbar-track {
    background: #111;
  }
</style>
</head>
<body>

<header>
  <input type="file" id="fileInput" accept=".dat" />
  <input type="text" id="search" placeholder="Case-sensitive search..." disabled />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="version">v1.0.0 VR Edition</div>
</header>

<div id="progressBar"><div></div></div>

<main>
  <div id="stringsContainer">
    <table>
      <thead>
        <tr>
          <th class="indexCol">#</th>
          <th class="origCol">Original String</th>
          <th class="modCol">Modified String</th>
        </tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</main>

<script>
(() => {
  'use strict';

  // UI Elements
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  // State variables
  let arrayBuffer = null;
  let dataView = null;
  let u8 = null;
  let fileName = '';

  // Il2Cpp metadata header info (these offsets are per VR global-metadata.dat known offsets)
  // Adapt if file format changes or different version
  const IL2CPP_MAGIC = 0xFAB11BAF;
  const HEADER_SIZE = 0x108; // 264 bytes for header (to read up to string literal data)
  let stringLiteralTableOffset = 0;
  let stringLiteralTableCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;

  // Store strings info: { index, entryOffset, stringDataOffset, length, original, modified }
  let stringLiterals = [];

  // Batch processing size to avoid UI freeze
  const BATCH_SIZE = 500; // number of strings parsed and rendered per chunk

  // TextDecoder instance for UTF-8 decoding
  const utf8Decoder = new TextDecoder('utf-8');

  // Enable/disable UI controls helpers
  function setLoading(isLoading) {
    fileInput.disabled = isLoading;
    searchInput.disabled = isLoading;
    saveBtn.disabled = isLoading || stringLiterals.length === 0;
  }

  // Update progress bar
  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  // Validate the magic number header for Il2Cpp global-metadata.dat
  function validateHeader() {
    const magic = dataView.getUint32(0, true);
    if (magic !== IL2CPP_MAGIC) {
      throw new Error('Invalid global-metadata.dat file magic number.');
    }
  }

  // Parse header info for string literal table offsets and sizes
  function parseHeader() {
    // Offsets based on Unity Il2Cpp version 29 (VR metadata)
    stringLiteralTableOffset = dataView.getUint32(0x58, true);
    stringLiteralTableCount = dataView.getUint32(0x5C, true);
    stringLiteralDataOffset = dataView.getUint32(0x60, true);
    stringLiteralDataSize = dataView.getUint32(0x64, true);

    if (
      stringLiteralTableOffset === 0 ||
      stringLiteralTableCount === 0 ||
      stringLiteralDataOffset === 0 ||
      stringLiteralDataSize === 0
    ) {
      throw new Error('Invalid or missing string literal table info in header.');
    }

    if (stringLiteralTableOffset + stringLiteralTableCount * 8 > u8.length) {
      throw new Error('String literal table offset/count outside file bounds.');
    }

    if (stringLiteralDataOffset + stringLiteralDataSize > u8.length) {
      throw new Error('String literal data offset/size outside file bounds.');
    }
  }

  // Validate if a Uint8Array contains mostly printable UTF-8 bytes (including spaces)
  function isValidStringBytes(bytes) {
    // Check if bytes contain valid UTF-8 and printable characters
    // Here we simply check ASCII range plus common UTF-8 multibyte (basic)
    try {
      const str = utf8Decoder.decode(bytes);
      // Remove trailing nulls/spaces
      const cleanStr = str.replace(/\0+$/g, '').trim();
      if (cleanStr.length === 0) return false;
      // Allow spaces and normal printable chars; reject control chars except \t, \n
      return /^[\t\n\r\x20-\x7E\xA0-\xFF]+$/.test(cleanStr);
    } catch {
      return false;
    }
  }

  // Read a string literal entry at given index (parses from table)
  function readStringLiteralEntry(index) {
    const entryOffset = stringLiteralTableOffset + index * 8;
    const relDataOffset = dataView.getUint32(entryOffset, true);
    const length = dataView.getUint32(entryOffset + 4, true);
    if (relDataOffset === 0 || length === 0) {
      return null;
    }
    const absDataOffset = stringLiteralDataOffset + relDataOffset;
    if (absDataOffset + length > u8.length) {
      return null;
    }
    const bytes = u8.slice(absDataOffset, absDataOffset + length);
    if (!isValidStringBytes(bytes)) {
      return null;
    }
    const originalStr = utf8Decoder.decode(bytes);
    return {
      index,
      entryOffset,
      stringDataOffset: absDataOffset,
      length,
      original: originalStr,
      modified: originalStr,
    };
  }

  // Incremental async batch load strings with UI updates
  async function loadStringsIncremental() {
    stringLiterals = [];
    tableBody.innerHTML = '';
    setLoading(true);
    updateProgress(0);

    for (let start = 0; start < stringLiteralTableCount; start += BATCH_SIZE) {
      for (let i = start; i < Math.min(start + BATCH_SIZE, stringLiteralTableCount); i++) {
        try {
          const entry = readStringLiteralEntry(i);
          if (entry) stringLiterals.push(entry);
        } catch (e) {
          // skip invalid entry
        }
      }
      renderTableRows(stringLiterals, start);
      updateProgress((start + BATCH_SIZE) / stringLiteralTableCount);
      await new Promise(r => setTimeout(r, 1)); // Yield to UI thread
    }

    updateProgress(1);
    setLoading(false);
    searchInput.disabled = false;
    saveBtn.disabled = false;
  }

  // Render table rows incrementally
  function renderTableRows(entries, startIndex) {
    // Append rows to table body
    const fragment = document.createDocumentFragment();
    for (let i = startIndex; i < entries.length; i++) {
      const entry = entries[i];
      if (!entry._rowCreated) {
        const tr = document.createElement('tr');
        // Index
        const tdIndex = document.createElement('td');
        tdIndex.className = 'indexCol';
        tdIndex.textContent = entry.index + 1;
        tr.appendChild(tdIndex);
        // Original string (readonly)
        const tdOrig = document.createElement('td');
        tdOrig.className = 'origCol';
        tdOrig.textContent = entry.original;
        tr.appendChild(tdOrig);
        // Modified string (editable)
        const tdMod = document.createElement('td');
        tdMod.className = 'modCol';
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'editInput';
        input.value = entry.modified;
        input.spellcheck = false;
        input.addEventListener('input', e => {
          entry.modified = e.target.value;
          saveBtn.disabled = false; // Enable save if modified
        });
        tdMod.appendChild(input);
        tr.appendChild(tdMod);

        entry._rowElement = tr;
        entry._modInput = input;
        entry._rowCreated = true;
        fragment.appendChild(tr);
      }
    }
    tableBody.appendChild(fragment);
  }

  // Search/filter table rows by original or modified string substring (case-sensitive)
  function filterTable(searchTerm) {
    if (!searchTerm) {
      // Show all
      for (const entry of stringLiterals) {
        if (entry._rowElement) entry._rowElement.style.display = '';
      }
      return;
    }
    for (const entry of stringLiterals) {
      if (!entry._rowElement) continue;
      const originalContains = entry.original.includes(searchTerm);
      const modifiedContains = entry.modified.includes(searchTerm);
      entry._rowElement.style.display = originalContains || modifiedContains ? '' : 'none';
    }
  }

  // Save modified strings by appending new strings at the end and updating string literal table offsets
  function saveModifiedFile() {
    setLoading(true);
    saveBtn.disabled = true;

    // Prepare new buffer: old file + appended strings + updated table

    // 1) Collect appended strings (modified ones different from original)
    const appendedStrings = [];
    const appendedOffsets = []; // new relative offsets to stringLiteralData base

    // We'll append strings after the original stringLiteralDataOffset + stringLiteralDataSize
    let appendStart = stringLiteralDataOffset + stringLiteralDataSize;
    let appendOffsetCursor = 0;

    for (const entry of stringLiterals) {
      if (entry.modified !== entry.original && entry.modified.length > 0) {
        // Encode new string UTF-8 + null terminator
        const encoded = new TextEncoder().encode(entry.modified);
        appendedStrings.push(encoded);
        appendedOffsets.push(appendOffsetCursor);
        appendOffsetCursor += encoded.length;
      } else {
        // No change, push null offset to mark no change
        appendedOffsets.push(null);
      }
    }

    // Calculate new size for appended strings block
    const appendedSize = appendOffsetCursor;

    // Create new output buffer: old file size + appended strings size
    const newBufferLength = u8.length + appendedSize;
    const newBuffer = new Uint8Array(newBufferLength);
    newBuffer.set(u8, 0);

    // Write appended strings at the end
    let writeCursor = u8.length;
    for (let i = 0; i < appendedStrings.length; i++) {
      newBuffer.set(appendedStrings[i], writeCursor);
      writeCursor += appendedStrings[i].length;
    }

    // Now update the string literal table (each entry 8 bytes)
    // For modified entries, update the offset to point to appended strings area (relative to stringLiteralDataOffset)
    // For unmodified entries, keep original offset
    for (let i = 0; i < stringLiteralTableCount; i++) {
      const entryOffset = stringLiteralTableOffset + i * 8;
      const relDataOffset = dataView.getUint32(entryOffset, true);
      const length = dataView.getUint32(entryOffset + 4, true);

      if (i >= appendedOffsets.length || appendedOffsets[i] === null) {
        // Unchanged entry, copy original offset and length
        const view = new DataView(newBuffer.buffer, entryOffset, 8);
        view.setUint32(0, relDataOffset, true);
        view.setUint32(4, length, true);
      } else {
        // Modified: update offset to appended offset + original stringLiteralDataSize (relative)
        const newRelOffset = stringLiteralDataSize + appendedOffsets[i];
        const newStrBytes = appendedStrings.shift();
        const newLength = newStrBytes.length;
        const view = new DataView(newBuffer.buffer, entryOffset, 8);
        view.setUint32(0, newRelOffset, true);
        view.setUint32(4, newLength, true);
      }
    }

    // Save new buffer as file
    const blob = new Blob([newBuffer], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName.replace(/(\.dat)?$/, '_modified.dat');
    a.click();
    URL.revokeObjectURL(url);

    setLoading(false);
  }

  // Handle file input
  fileInput.addEventListener('change', async (e) => {
    if (!e.target.files || e.target.files.length === 0) return;
    const file = e.target.files[0];
    fileName = file.name;
    setLoading(true);
    tableBody.innerHTML = '';
    searchInput.value = '';
    searchInput.disabled = true;
    saveBtn.disabled = true;
    updateProgress(0);

    try {
      arrayBuffer = await file.arrayBuffer();
      dataView = new DataView(arrayBuffer);
      u8 = new Uint8Array(arrayBuffer);

      validateHeader();
      parseHeader();

      await loadStringsIncremental();

      searchInput.disabled = false;
      saveBtn.disabled = false;
    } catch (err) {
      alert('Error parsing file: ' + err.message);
      setLoading(false);
      tableBody.innerHTML = '';
      searchInput.disabled = true;
      saveBtn.disabled = true;
      updateProgress(0);
    }
  });

  // Search input event
  searchInput.addEventListener('input', (e) => {
    filterTable(e.target.value);
  });

  // Save button event
  saveBtn.addEventListener('click', () => {
    saveModifiedFile();
  });

})();
</script>

</body>
</html>
