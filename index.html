<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Il2Cpp Metadata String Editor</title>
<style>
  body { font-family: monospace; margin: 0; background: #111; color: #eee; }
  header { padding: 0.5em 1em; background: #222; position: relative; }
  input[type=file] { margin-right: 1em; }
  #progressBar {
    width: 100%; height: 20px; background: #333; margin: 0.5em 0;
    border-radius: 3px; overflow: hidden;
  }
  #progressBar div {
    height: 100%; background: #76aaff; width: 0%;
  }
  #search {
    width: 300px; padding: 0.3em; margin-bottom: 1em;
    background: #222; border: 1px solid #555; color: #eee;
  }
  #container {
    display: flex;
    height: 75vh;
    overflow: hidden;
  }
  table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  th, td {
    border: 1px solid #333;
    padding: 0.2em 0.4em;
    overflow-wrap: break-word;
    word-break: break-all;
    vertical-align: top;
    background: #222;
  }
  th {
    background: #333;
  }
  td input {
    width: 100%;
    background: transparent;
    border: none;
    color: #eee;
    font-family: monospace;
  }
  td input:focus {
    outline: 1px solid #76aaff;
  }
  #stringsTable {
    flex: 1;
    overflow: auto;
  }
  #version {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 0.75em;
    color: #888;
  }
</style>
</head>
<body>
<header>
  <input type="file" id="fileInput" />
  <input type="text" id="search" placeholder="Case-sensitive search..." />
  <button id="saveBtn" disabled>Save Modified File</button>
  <div id="progressBar"><div></div></div>
  <div id="version">v1.4.0</div>
</header>
<div id="container">
  <div id="stringsTable">
    <table>
      <thead>
        <tr><th style="width: 5%;">Index</th><th style="width: 45%;">Original String</th><th style="width: 50%;">Modified String</th></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('search');
  const saveBtn = document.getElementById('saveBtn');
  const progressBar = document.getElementById('progressBar').firstElementChild;
  const tableBody = document.getElementById('tableBody');

  let arrayBuffer;
  let dataView;
  let stringLiterals = [];
  let stringLiteralOffset = 0;
  let stringLiteralCount = 0;
  let stringLiteralDataOffset = 0;
  let stringLiteralDataSize = 0;
  let fileName = '';

  function updateProgress(ratio) {
    progressBar.style.width = Math.floor(ratio * 100) + '%';
  }

  function isLikelyString(bytes) {
    for (let b of bytes) {
      if (b === 0) continue;
      if (b < 32 || b > 126) return false;
    }
    return true;
  }

  function renderFiltered() {
    const filter = searchInput.value;
    const frag = document.createDocumentFragment();
    let count = 0;
    for (let s of stringLiterals) {
      if (filter && !s.original.includes(filter) && !s.modified.includes(filter)) continue;
      const tr = document.createElement('tr');
      const tdIndex = document.createElement('td');
      tdIndex.textContent = s.index;
      tr.appendChild(tdIndex);

      const tdOrig = document.createElement('td');
      tdOrig.textContent = s.original;
      tr.appendChild(tdOrig);

      const tdMod = document.createElement('td');
      const input = document.createElement('input');
      input.type = 'text';
      input.value = s.modified;
      input.spellcheck = false;
      input.addEventListener('input', e => {
        s.modified = e.target.value;
      });
      tdMod.appendChild(input);
      tr.appendChild(tdMod);

      frag.appendChild(tr);
      if (++count > 1000) break; // avoid freezing
    }
    tableBody.innerHTML = '';
    tableBody.appendChild(frag);
  }

  async function parseStringLiterals() {
    const u8 = new Uint8Array(arrayBuffer);
    dataView = new DataView(arrayBuffer);
    const magic = dataView.getUint32(0, true);
    if (magic !== 0xFAB11BAF) {
      alert('Invalid global-metadata.dat file.');
      return;
    }

    stringLiteralOffset = dataView.getUint32(88, true);
    stringLiteralCount = dataView.getUint32(92, true);
    stringLiteralDataOffset = dataView.getUint32(96, true);
    stringLiteralDataSize = dataView.getUint32(100, true);

    stringLiterals = [];
    for (let i = 0; i < stringLiteralCount; i++) {
      const entryOffset = stringLiteralOffset + i * 8;
      const relOffset = dataView.getUint32(entryOffset, true);
      const length = dataView.getUint32(entryOffset + 4, true);
      const absOffset = stringLiteralDataOffset + relOffset;
      if (absOffset + length > u8.length) continue;
      const bytes = u8.slice(absOffset, absOffset + length);
      const nullTerminated = bytes.indexOf(0);
      const cleanBytes = nullTerminated !== -1 ? bytes.slice(0, nullTerminated) : bytes;
      if (!isLikelyString(cleanBytes)) continue;
      const str = new TextDecoder().decode(cleanBytes);
      stringLiterals.push({ index: i, offset: entryOffset, length, original: str, modified: str });
    }
    updateProgress(1);
    saveBtn.disabled = false;
    renderFiltered();
  }

  fileInput.addEventListener('change', async e => {
    if (!e.target.files.length) return;
    const file = e.target.files[0];
    fileName = file.name;
    const reader = new FileReader();
    reader.onload = async () => {
      arrayBuffer = reader.result;
      await parseStringLiterals();
    };
    reader.readAsArrayBuffer(file);
  });

  searchInput.addEventListener('input', renderFiltered);

  saveBtn.addEventListener('click', () => {
    const modified = stringLiterals.filter(s => s.original !== s.modified);
    if (!modified.length) return alert('No changes to save.');

    const old = new Uint8Array(arrayBuffer);
    const newData = [];
    let appendOffset = old.length;

    const newTable = new Uint8Array(stringLiteralCount * 8);
    const newView = new DataView(newTable.buffer);

    for (let s of stringLiterals) {
      let offset, length;
      if (s.original !== s.modified) {
        const bytes = new TextEncoder().encode(s.modified);
        offset = appendOffset - stringLiteralDataOffset;
        length = bytes.length;
        newData.push({ offset: appendOffset, bytes });
        appendOffset += length;
      } else {
        offset = dataView.getUint32(s.offset, true);
        length = s.length;
      }
      newView.setUint32(s.index * 8, offset, true);
      newView.setUint32(s.index * 8 + 4, length, true);
    }

    const result = new Uint8Array(appendOffset);
    result.set(old, 0);
    for (let chunk of newData) {
      result.set(chunk.bytes, chunk.offset);
    }
    result.set(new Uint8Array(newTable.buffer), stringLiteralOffset);

    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName.replace(/\.dat$/, '') + '_modded.dat';
    a.click();
    URL.revokeObjectURL(url);
  });
})();
</script>
</body>
</html>
