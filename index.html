<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Robust Global Metadata String Editor</title>
<style>
  body {
    background: #121212; color: #eee; font-family: monospace; margin:0; padding:1rem;
    display: flex; flex-direction: column; height: 100vh;
  }
  #topbar {
    display: flex; gap: 1rem; margin-bottom: 1rem; align-items: center;
  }
  input[type="file"] {
    background: #222; border: none; padding: 0.5rem; color: #eee; border-radius: 4px;
  }
  input[type="text"] {
    background: #222; border: none; padding: 0.5rem; color: #eee; border-radius: 4px;
    flex: 1;
  }
  button {
    background: #4caf50; border:none; padding: 0.5rem 1rem; border-radius: 4px; color:#121212;
    cursor: pointer;
  }
  button:disabled {
    background: #666; cursor: default;
  }
  #progress-container {
    width: 100%; height: 22px; background: #333; border-radius: 11px; overflow: hidden;
    margin-bottom: 1rem;
  }
  #progress-bar {
    height: 100%; width: 0%; background: #4caf50; transition: width 0.2s ease;
    display: flex; align-items: center; justify-content: center; font-size: 0.9rem;
    color: #121212; font-weight: bold; user-select:none;
  }
  #string-list {
    flex: 1; overflow-y: auto; background: #1e1e1e; border: 1px solid #444; border-radius: 6px;
    padding: 0.5rem;
  }
  .string-item {
    display: flex; gap: 1rem; margin-bottom: 0.3rem; align-items: center;
  }
  .string-col {
    flex: 1 1 45%; display: flex; flex-direction: column;
  }
  label {
    font-size: 0.7rem; color: #bbb; margin-bottom: 0.1rem; user-select:none;
  }
  input.string-input {
    background: #000; border: 1px solid #555; border-radius: 4px; color: #eee;
    padding: 0.2rem 0.4rem; font-family: monospace; font-size: 1rem;
    width: 100%;
    box-sizing: border-box;
  }
  input[readonly] {
    background: #222; color: #777; cursor: default;
  }
  #status-text {
    margin-top: 0.5rem; font-size: 0.9rem; color: #888;
    user-select:none;
  }
</style>
</head>
<body>

<div id="topbar">
  <input type="file" id="file-input" accept=".dat" />
  <input type="text" id="search" placeholder="Case-sensitive search" disabled />
  <button id="download-btn" disabled>Download</button>
</div>

<div id="progress-container" aria-label="Progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" style="display:none;">
  <div id="progress-bar">0%</div>
</div>

<div id="string-list" aria-live="polite" aria-relevant="additions"></div>
<div id="status-text"></div>

<script>
(() => {
  const fileInput = document.getElementById('file-input');
  const progressBar = document.getElementById('progress-bar');
  const progressContainer = document.getElementById('progress-container');
  const stringList = document.getElementById('string-list');
  const searchInput = document.getElementById('search');
  const downloadBtn = document.getElementById('download-btn');
  const statusText = document.getElementById('status-text');

  // Global variables for file buffer and string entries
  let buffer = null;
  let entries = [];
  let filteredEntries = [];
  let originalDomCache = new Map(); // cache original DOM nodes keyed by entry id
  let visibleEntryCount = 0;

  // Config
  const BATCH_STRINGS_RENDER = 50;    // how many strings to append to DOM per batch render call
  const MAX_VISIBLE_RESULTS = 1000;   // max number of strings shown for performance (pagination can be added)
  const MIN_STRING_LEN = 3;

  // Helpers
  const textDecoder = new TextDecoder('ascii');
  const textEncoder = new TextEncoder();

  // requestIdleCallback fallback
  const idleCallback = window.requestIdleCallback || function (fn) { return setTimeout(fn, 50); };

  // Utility debounce function for search input
  function debounce(fn, delay) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn(...args), delay);
    };
  }

  // Update progress bar UI
  function updateProgress(percent) {
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
    progressContainer.setAttribute('aria-valuenow', percent);
  }

  // Clear all current displayed strings from DOM and cache
  function clearDisplayedStrings() {
    stringList.innerHTML = '';
    originalDomCache.clear();
    visibleEntryCount = 0;
  }

  // Create a DOM element for one string entry (or reuse cached one)
  function createOrReuseEntryElement(entry) {
    if (originalDomCache.has(entry.id)) {
      return originalDomCache.get(entry.id);
    }

    const div = document.createElement('div');
    div.className = 'string-item';
    div.dataset.id = entry.id;

    // Original string column
    const colOrig = document.createElement('div');
    colOrig.className = 'string-col';
    const labelOrig = document.createElement('label');
    labelOrig.textContent = `Offset: 0x${entry.offset.toString(16).toUpperCase().padStart(8, '0')}`;
    const inputOrig = document.createElement('input');
    inputOrig.type = 'text';
    inputOrig.readOnly = true;
    inputOrig.className = 'string-input';
    inputOrig.value = entry.original;

    colOrig.appendChild(labelOrig);
    colOrig.appendChild(inputOrig);

    // Modified string column
    const colMod = document.createElement('div');
    colMod.className = 'string-col';
    const labelMod = document.createElement('label');
    labelMod.textContent = 'Modified';
    const inputMod = document.createElement('input');
    inputMod.type = 'text';
    inputMod.className = 'string-input';
    inputMod.value = entry.modified;

    // On user input, update entry.modified (filter out non-printable ascii)
    inputMod.addEventListener('input', () => {
      let val = inputMod.value;
      // Allow printable ASCII only (space to ~)
      val = val.replace(/[^\x20-\x7E]/g, '');
      if (val !== inputMod.value) inputMod.value = val;
      entry.modified = val;
    });

    colMod.appendChild(labelMod);
    colMod.appendChild(inputMod);

    div.appendChild(colOrig);
    div.appendChild(colMod);

    originalDomCache.set(entry.id, div);
    return div;
  }

  // Render a batch of strings to DOM incrementally to avoid freezes
  function renderStringsIncrementally(strings, startIndex = 0) {
    if (startIndex >= strings.length || visibleEntryCount >= MAX_VISIBLE_RESULTS) {
      updateStatus(`Displayed ${visibleEntryCount} strings.`);
      return;
    }

    const fragment = document.createDocumentFragment();
    let count = 0;

    for (let i = startIndex; i < strings.length && count < BATCH_STRINGS_RENDER && visibleEntryCount < MAX_VISIBLE_RESULTS; i++, count++, visibleEntryCount++) {
      fragment.appendChild(createOrReuseEntryElement(strings[i]));
    }

    stringList.appendChild(fragment);

    // Schedule next batch
    idleCallback(() => {
      renderStringsIncrementally(strings, startIndex + count);
    });
  }

  // Show filtered strings with batching and virtual limit
  function showFilteredStrings(query) {
    clearDisplayedStrings();

    if (!query) {
      filteredEntries = entries;
    } else {
      filteredEntries = entries.filter(e => e.original.includes(query) || e.modified.includes(query));
    }

    visibleEntryCount = 0;
    renderStringsIncrementally(filteredEntries);
  }

  // Incrementally extract strings from file buffer in small chunks to avoid freezes
  function incrementalExtractStrings(buf) {
    entries = [];
    clearDisplayedStrings();

    const len = buf.length;
    let pos = 0;
    let idCounter = 0;

    updateStatus('Extracting strings...');
    progressContainer.style.display = 'block';
    updateProgress(0);

    function extractChunk(deadline) {
      while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && pos < len) {
        if (buf[pos] >= 0x20 && buf[pos] <= 0x7E) {
          const start = pos;
          while (pos < len && buf[pos] >= 0x20 && buf[pos] <= 0x7E) pos++;
          const strLen = pos - start;
          if (strLen >= MIN_STRING_LEN) {
            const str = textDecoder.decode(buf.slice(start, pos));
            entries.push({ id: idCounter++, offset: start, original: str, modified: str });
          }
        } else {
          pos++;
        }
      }

      updateProgress(Math.floor((pos / len) * 100));

      if (pos < len) {
        requestIdleCallback(extractChunk, { timeout: 50 });
      } else {
        updateProgress(100);
        progressContainer.style.display = 'none';
        updateStatus(`Extraction complete. ${entries.length} strings found.`);
        searchInput.disabled = false;
        downloadBtn.disabled = false;
        filteredEntries = entries;
        renderStringsIncrementally(entries);
      }
    }

    requestIdleCallback(extractChunk, { timeout: 50 });
  }

  // Update status text below list
  function updateStatus(text) {
    statusText.textContent = text;
  }

  // File load event
  fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (!file) return;

    searchInput.value = '';
    searchInput.disabled = true;
    downloadBtn.disabled = true;
    entries = [];
    filteredEntries = [];
    originalDomCache.clear();
    stringList.innerHTML = '';
    visibleEntryCount = 0;
    buffer = null;
    updateStatus('');

    const reader = new FileReader();
    reader.onload = () => {
      buffer = new Uint8Array(reader.result);
      incrementalExtractStrings(buffer);
    };
    reader.readAsArrayBuffer(file);
  });

  // Debounced search input handling
  searchInput.addEventListener('input', debounce(() => {
    if (!buffer) return;
    const q = searchInput.value;
    updateStatus(q ? `Searching for "${q}"...` : '');
    showFilteredStrings(q);
  }, 250));

  // Download patched file event
  downloadBtn.addEventListener('click', () => {
    if (!buffer || entries.length === 0) return;

    updateStatus('Generating patched file...');

    // Create copy of original buffer for patching
    const patched = new Uint8Array(buffer);

    // Patch strings in-place
    entries.forEach(e => {
      // Prepare encoded modified string padded or truncated to original length
      let modStr = e.modified;
      if (modStr.length > e.original.length) {
        // If longer, truncate to original length (for safety)
        modStr = modStr.slice(0, e.original.length);
      } else if (modStr.length < e.original.length) {
        // Pad with null bytes to keep offset stable
        modStr = modStr.padEnd(e.original.length, '\0');
      }
      const modEncoded = textEncoder.encode(modStr);
      patched.set(modEncoded, e.offset);
    });

    // Trigger download
    const blob = new Blob([patched], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'patched-global-metadata.dat';
    a.click();

    URL.revokeObjectURL(url);
    updateStatus('Download complete.');
  });

  // Init UI state
  searchInput.disabled = true;
  downloadBtn.disabled = true;
  updateStatus('Load a .dat file to start.');
})();
</script>

</body>
</html>
